{"meta":{"title":"Yangyang's Blog","subtitle":"","description":" Yangyyang 的个人博客，框架 Hexo，主题 Butterfly。Yangyang —— 李洋，一个前端，会点 Vue，博客主要用来做笔记，记录学习，分享技巧。","author":"Yangyang","url":"https://liyang1998.gitee.io","root":"/"},"pages":[{"title":"","date":"2021-04-29T04:09:41.158Z","updated":"2021-04-29T04:09:41.158Z","comments":true,"path":"baidupush.js","permalink":"https://liyang1998.gitee.io/baidupush.js","excerpt":"","text":"(function () { var bp = document.createElement(\"script\"); var curProtocol = window.location.protocol.split(\":\")[0]; if (curProtocol === \"https\") { bp.src = \"https://zz.bdstatic.com/linksubmit/push.js\"; } else { bp.src = \"http://push.zhanzhang.baidu.com/push.js\"; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })();"},{"title":"Ordinary but unique","date":"2020-02-27T08:30:12.000Z","updated":"2021-04-12T08:03:22.378Z","comments":false,"path":"about/index.html","permalink":"https://liyang1998.gitee.io/about/index.html","excerpt":"","text":".title p{ font-size: 20px;} .content{ padding-left: 15px; font-size: 16px;} 关于我 Yangyang 一个前端 喜欢音乐、游戏 关于博客 本博客是基于Hexo搭建的，主题为Butterfly"},{"title":"分类","date":"2020-02-26T12:45:57.000Z","updated":"2021-04-28T14:55:31.192Z","comments":false,"path":"categories/index.html","permalink":"https://liyang1998.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-02-26T12:46:50.000Z","updated":"2021-04-02T01:54:56.142Z","comments":true,"path":"link/index.html","permalink":"https://liyang1998.gitee.io/link/index.html","excerpt":"","text":""},{"title":"留下足迹","date":"2020-02-26T12:49:17.000Z","updated":"2021-04-21T14:10:30.791Z","comments":true,"path":"messageboard/index.html","permalink":"https://liyang1998.gitee.io/messageboard/index.html","excerpt":"","text":"有什么想说的 有什么想问的 有什么想吐槽的 在下面留言告诉我吧"},{"title":"热爱生活，热爱音乐","date":"2020-02-26T12:54:38.000Z","updated":"2021-04-06T03:41:55.002Z","comments":true,"path":"music/index.html","permalink":"https://liyang1998.gitee.io/music/index.html","excerpt":"","text":"IU var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":0,\"mode\":\"random\",\"mutex\":true,\"theme\":\"#e6d0b2\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"삐삐 - (BBIBBI)\",\"author\":\"IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=1316563427\",\"pic\":\"https://pic.xiami.net/images/album/img14/196/5bbdc4a4491bc_9841114_1539163300.jpg?x-oss-process=image/quality,q_80/format,jpg\"},{\"title\":\"Blueming\",\"author\":\"IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=1404511131\",\"pic\":\"https://pic.xiami.net/images/album/img67/13/5dd25f4b8247f_679267_1574068043.jpg?x-oss-process=image/quality,q_80/format,jpg\"},{\"title\":\"Love poem\",\"author\":\"IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=1400436688\",\"pic\":\"https://pic.xiami.net/images/album/img9/60/5dbbf5e4db403_3020209_1572599268.jpg?x-oss-process=image/quality,q_80/format,jpg\"},{\"title\":\"囍帖街 (Live)\",\"author\":\"IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=35847131\",\"pic\":\"https://pic.xiami.net/images/album/img22/56822/21003906211474253302.jpeg?x-oss-process=image/quality,q_80/format,jpg\"},{\"title\":\"봄 사랑 벚꽃 말고 (除了春天 爱情和樱花)\",\"author\":\"High4 / IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=28391219\",\"pic\":\"https://pic.xiami.net/images/album/img82/1895391682/2970987581402380352.jpg?x-oss-process=image/quality,q_80/format,jpg\"}]}; options.element = document.getElementById(\"aplayer-vfXbJENn\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);"},{"title":"标签","date":"2020-02-26T12:44:18.000Z","updated":"2021-04-28T14:55:20.946Z","comments":false,"path":"tags/index.html","permalink":"https://liyang1998.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript 基础知识总结","slug":"JavaScript-一些基础知识总结","date":"2021-04-29T16:14:17.000Z","updated":"2021-04-29T16:40:50.567Z","comments":true,"path":"posts/e5b43a6.html","link":"","permalink":"https://liyang1998.gitee.io/posts/e5b43a6.html","excerpt":"","text":"文章内容为本人在最初学习 JS 时整理的笔记由于技术有限，知识点较为基础，也稍微有些杂乱如有错误，欢迎指出 输入输出123prompt(); //弹出输入框alert(); //弹出提示框console.log(); //浏览器控制台打印 变量声明、赋值和变量的初始化12345var a; //声明a = 5; //赋值var b = 10; //初始化b = 20; //重新赋值var x=1,y=2,z=3; //同时声明多个变量，可以只写一个var，中间用‘,’隔开 特殊情况 只声明 不赋值 -&gt; undefined 不声明 不赋值 -&gt; 使用时会报错 不声明直接赋值 -&gt; 可以使用 变量命名规范 由字母、数字、下划线、美元符号$组成 严格区分大小写 不能以数字开头 不能是关键字、保留字 变量名必须有意义 遵守驼峰命名法 数据类型 typeof -&gt; 返回数据类型 基本数据类型 Number 数字 Boolean 布尔值 String 字符串 undefined 未定义 null 空值 （ES6新增） Symbol 唯一标识符 引用数据类型 Object 对象 基本和引用类型的区别 JS中的变量都是保存到栈内存中的 基本数据类型的值直接在栈内存中存储 值与值之间是独立存在的，修改一个变量不会影响其他变量 对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间 而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用，当通过一个变量修改属性时，另一个也会受到影响 当比较两个基本数据类型时，就是比较它们的值 当比较两个引用数据类型时，比较的是对象的内存地址 两个对象即使一模一样，如果地址不同，也会返回false 数据类型转换 转换为字符串 变量.toString() String(变量) 强制转换 ‘+’拼接字符串(隐式转换，推荐) 转换为数字型 parseInt(string) 函数 将string类型转成整型 parseFloat(string) 函数 将string类型转成浮点型 Number() 强制转换函数 将string类型转成数字型 隐式转换 利用算术运算符隐式转换 转换为布尔型 Boolean() 函数：代表空、否定的值都会被转换为false。 对象和函数对象的分类 内建对象 由ES标准中定义的对象，在任何ES的实现中都可以使用 比如： Math String Number Boolean Function Object 宿主对象 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象比如 BOM DOM 自定义对象 由开发人员自己创建的对象 作用域 作用域指一个变量的作用范围 在JS中一共有两种作用域： 全局作用域 直接编写在script标签中的JS代码，都在全局作用域 全局作用域在页面打开时创建，在页面关闭时销毁 在全局作用域中有一个全局对象window它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用 在全局作用域中：创建的变量都会作为window对象的属性保存创建的函数都会作为window对象的方法保存 全局作用域中的变量都是全局变量，在页面的任意部分都可以访问到 函数作用域 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁 没调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的 在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量 当在函数作用域中操作变量时，现在自身作用域中寻找，如果有就直接使用，没有则去上一级作用域中寻找 this解析器在调用函数时会向函数内部传递一个隐含的参数，这个隐含的参数就是this， this指向的是一个对象，这个对象我们称为为函数执行的上下文对象， 根据函数的调用方式的不同，this会指向不同的对象， 主要有以下几个场景： 以函数的形式调用时，this永远都是window 以方法的形式调用时，this就是调用方法的那个对象 以构造函数的形式调用时，this就是新创建的那个对象 使用call和apply调用时，this是传入的那个对象 构造函数构造函数本质上就是一个普通的函数，创建方式和普通函数没有区别 构造函数命名上习惯首字母大写 构造函数需要使用new关键字来调用 构造函数的执行流程： 立刻创建一个新的对象 将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象 逐行执行函数中的代码 将新建的对象作为返回值返回 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类 我们将通过一个函数创建的对象，称为是该类的实例 this的情况： 当以函数的形式调用时，this就是window 当以方法的形式调用时，谁调用方法谁就是this 当以构造函数的形式调用时，this就是新创建的那个对象12345678910111213141516171819202122232425262728293031323334353637383940414243/* 创建一个Person构造函数 * - 在Person构造函数中，为每一个对象都添加了一个sayName方法 * 目前我们是在构造函数内部创建方法，这就导致了构造函数每执行一次就会创建一个方法 * 而且所有实例的sayName方法都是一模一样的但却是唯一的 * - 我们完全可以使所有对象共享一个方法 */function Person(name, age, gender)&#123; this.name = name; this.age = age; this.gender = gender; /*this.sayName = function()&#123; alert(&quot;大家好，我是&quot;+this.name); &#125;;*/ //将sayName方法在全局作用域中定义，而不是在内部创建 this.sayName = fun;&#125;//将sayName方法在全局作用域中定义/* * 将函数定义在全局作用域，污染了全局作用域的命名空间 * 而且定义在全局作用域中也很不安全 * 解决：原型 */function fun()&#123; alert(&quot;大家好，我是&quot;+this.name);&#125;//创建Person类的实例var person1 = new Person(&quot;李四&quot;, 18, &quot;男&quot;);var person2 = new Person(&quot;王五&quot;, 16, &quot;女&quot;);person1.sayName();person2.sayName();//使用instanceof可以检查一个对象是否是一个类的实例//console.log(person1 instanceof Person); //true/* * 所有对象都是Object的后代 * 所以任何对象和Object作instanceof检查时都会返回true *///console.log(person1 instanceof Object); //true 原型 函数 prototype 属性 ==》 原型对象 （显式原型） ​ 在定义函数时自动添加的，默认值是一个空的Object实例对象(Object例外) 实例 _proto_ 属性 ==》 原型对象 （隐式原型） ​ 在创建对象时自动添加的，默认值为构造函数的prototype属性值 ​ 即实例对象的隐式原型的值为其对应的构造函数显式原型的值 ​ 我们能直接操作显式原型，但不能操作隐式原型 原型对象 constructor 属性 ==》 函数对象 所有函数的 _proto_ 都是一样的(都是由构造函数Function创建的实例，包括Function本身） Object的原型对象是原型链的尽头(Object.prototype._proto_ == null) 123456789101112131415161718192021222324252627282930313233343536373839/* * 原型prototype * 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype * 这个属性对应着一个对象，这个对象就是我们所谓的原型对象 * 如果函数作为普通函数调用prototype没有任何作用 * 当函数以创造函数的形式调用时，它所创建的对象中都会有一个隐含的属性 * 指向该构造函数的原型对象，我们可以通过__proto__来访问 * * 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到 * 我们可以将对象中共有的内容，统一设置到原型对象中 * * 当我们访问对象的属性或方法时，会现在对象自身中寻找，如果有则直接使用， * 没有则去原型中寻找... 直到找到Object的原型 * Object的原型没有原型(null)，如果在Object的原型中依然没有找到，则返回undefined * * 以后我们创建构造函数时，可以将这些对象共有的属性和方法，添加到构造函数的原型对象中 */function MyClass()&#123; &#125;//向MyClass的原型中添加属性aMyClass.prototype.a = 123;//向MyClass的原型中添加方法MyClass.prototype.sayHello = function()&#123; alert(&quot;Hello&quot;);&#125;;var mc = new MyClass();var mc2 = new MyClass();mc2.a = &quot;我是mc2中的a&quot;;//console.log(MyClass.prototype);//console.log(mc.__proto__ == MyClass.prototype); //trueconsole.log(mc.a); //123console.log(mc2.a); //我是mc2中的a 1234567891011121314151617function MyClass()&#123; &#125;//向MyClass的原型中添加属性nameMyClass.prototype.name = &quot;我是原型中的名字&quot;;var mc = new MyClass();mc.age = 18;//使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true//console.log(&quot;name&quot; in mc); //true//可以使用hasOwnProperty()来检查对象自身中是否有该属性//使用该方法只有当对象自身含有该属性时，才会返回trueconsole.log(mc.hasOwnProperty(&quot;name&quot;)); //falseconsole.log(mc.hasOwnProperty(&quot;age&quot;)); //true IIFEImmediately-Invoked Function Expression 立即调用函数表达式、 123456789//匿名函数自调用(function ()&#123; console.log(&quot;IIFE&quot;);&#125;)();/* 作用： * 隐藏实现 * 不会污染外部命名空间 */ instanceof 表达式 A instanceof B 如果B函数的显式原型对象在A对象的原型链上，则返回true 函数的方法12345678910111213141516171819202122232425262728293031323334353637function fun()&#123; alert(this); &#125;/* * call()和apply() * - 这两个方法都是函数对象的方法，需要通过函数对象来调用 * - 当对函数调用call()和apply()都会调用函数执行 * - 在调用call()和apply()时可以将一个对象指定为第一个参数 * 这个对象将会成为函数执行时的this */fun; //[object window]fun.call(); //[object Object]fun.apply(); //[object Object]/*============================================== - call()方法可以将实参在对象之后依次传递 - apply()方法需要将实参封装到一个数组中统一传递 ==============================================*/ function fun(a, b)&#123; console.log(&quot;a = &quot;+a); console.log(&quot;b = &quot;+b);&#125;var obj = &#123; name: &quot;obj&quot;, sayName: function()&#123; alert(this.name); &#125;&#125;;fun.call(obj); //a = undefined b = undefinedfun.call(obj, 2, 3);//a = 2 b = 3fun.apply(obj, [2,3]); this的情况 以函数的形式调用时，this永远都是window 以方法的形式调用时，this就是调用方法的那个对象 以构造函数的形式调用时，this就是新创建的那个对象 使用call和apply调用时，this是指的那个对象 arguments1234567891011/* * 在调用函数时，浏览器每次都会传递进两个隐含的参数： * 1.函数的上下文对线this * 2.封装实参的对象arguments * - arguments是一个类数组对象，它也可以通过索引来操作，也可以获取长度 * - 在调用函数时，我们所传递的参数都会在arguments中保存 * - arguments.length可以用来获取实参的数量 * - 即使不定义形参也可以通过arguments来使用实参 * - arguments里面有一个属性叫做callee * 这个属性对应的就是当前正在执行的函数对象 */ Date对象123456789101112131415161718192021222324//创建一个Date对象//如果直接使用构造函数创建Date对象，则会封装为当前代码执行的时间var d = new Date();//创建一个指定的Date对象//需要在构造函数中传递一个表示时间的字符串作为参数//日期格式 月/日/年 时:分:秒var myDate = new Date(&quot;12/25/2019 12:25:00&quot;);console.log(myDate); //Wed Dec 25 2019 12:25:00 GMT+0800 (中国标准时间)/*========================================================= 方法： getDate() 获取一个月中的某一天(今天是几号? 1-31) getDay() 获取一周中的某一天(今天是周几? 0-6,0表示周日) getMonth() 获取一年中的某月(0-11) ... getTime() 获取当前日期对象的时间戳 - 时间戳：从格林威治时间的1970年1月1日 0分0时0秒 到当前日期的毫秒数 - 计算机底层保存时间使用的是时间戳=========================================================*/ Math对象Math和其他对象不同，它不是一个构造函数，它属于一个工具类，不用创建对象，它里面封装了数学运算相关的属性和方法 属性 E,LN2,LN10,PI … 方法 abs(),sqrt(),max(),min() … ceil() 向上取整 floor() 向下取整 round() 四舍五入 random() 生成一个0-1之间的随机数 12//生成一个x-y之间的随机数Math.round(Math.random()*(y-x)+x); 数组数组的四个常用方法push() 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新长度 可以将要添加的元素作为方法的参数传递，这些元素将会自动添加到数组的末尾 pop() 该方法可以删除数组的最后一个元素，并将被删除的元素返回 unshift() 向数组开头添加一个或多个元素，并返回新的数组长度 添加元素后，其他元素的索引会相应调整 shift() 可以删除数组的第一个元素，并将其作为返回值返回 数组的遍历 for 循环 123456var arr = [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;马六&quot;];for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[i]);&#125; forEach * 1234567891011121314151617//forEach() 不支持IE9以下浏览器var arr = [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;马六&quot;];/* * forEach()方法需要一个函数作为参数 * - 像这种函数，由我们创建但不是我们调用的，我们称之为回调函数 * - 数组中有几个元素就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式 * 传递进来，我们可以定义形参，来读取这些内容 * - 浏览器会在回调函数中传递三个参数： * 第一个参数：当前正在遍历的元素 * 第二个参数：当前正在遍历的元素的索引 * 第三个参数：当前正在遍历的数组 */arr.forEach(function(value, index, obj)&#123; console.log(value);&#125;); slice()和splice()slice() 可以用来从数组中提取指定元素 参数：截取开始的位置索引，截取结束的位置索引 (前闭后开,第二个参数可以不写，默认取到最后一个元素) 索引可以是负值 -1为最后一个元素 splice() 删除元素并向数组添加新元素 将指定元素从原数组中删除并返回 参数：第一个：开始位置索引第二个：删除的数量第三个及以后：可以传递一些新的元素，这些元素会自动插入到开始索引位置之前 数组去重123456789101112131415161718192021//创建一个数组var arr = [1,2,3,2,1,3,4,2,5];//数组去重1 //获取数组中的每一个元素（遍历）for(var i=0; i&lt;arr.length; i++)&#123; //遍历当前元素后的所有元素 for(var j=i+1; j&lt;arr.length; j++)&#123; //判断两个元素值是否相等 if(arr[i]==arr[j])&#123; //相等则证明出现重复，删除j对应元素 arr.splice(j,1); //当删除了当前j所对应元素后，后面的元素会自动补位 //导致j新对应的元素无法进行比较，如果该元素依旧重复则会遗漏 //故使j自减 j--; &#125; &#125;&#125;console.log(arr); 数组其他方法123456789101112131415161718192021222324252627282930313233343536/* 1 * concat()可以连接两个或多个数组，并将新的数组返回 * - 该方法不会对原数组产生影响 * - 参数也可以为元素 *//* 2 * join()方法可以将数组转换为一个字符串 * - 该方法不会对原数组产生影响，而是将转换后的结果返回 * - 可以指定一个字符串作为参数，它将会作为数组元素的连接符，不填则默认为&quot;,&quot; *//* 3 * reverse()方法可以用来反转数组 * - 会直接操作原数组 *//* 4 * sort()用来对数组元素进行排序 * - 改变原数组 * - 默认按照Unicode编码进行排序，即使对纯数字数组排序一会按照Unicode编码排序 * - 我们可以自己指定排序规则，在sort()添加一个回调函数 * 回调函数中需要定义两个形参 * 浏览器将会分别使用数组中的元素作为实参去调用回调函数 * - 浏览器会根据回调函数的返回值来决定元素的顺序 * 如果返回一个大于0的值，则元素交换位置 * 如果返回一个小于0的值，则元素位置不变 * 如果返回一个0，则认为两个元素相等，不交换位置 */var arr = [5,4];arr.sort(function(a,b)&#123; return a - b; //升序 //return b - a; //降序&#125;); 包装类在JS中为我们提供了三个包装类，通过包装类可以将基本数据类型转换为对象 String() Number() Boolean() 但是我们在实际应用中不会使用基本数据类型的对象。 方法和属性只能添加给对象，不能添加给基本数据类型 当我们对一些基本数据类型去调用属性和方法时 浏览器会临时使用包装类将其转换为对象，然后再调用属性和方法 12345678var s = 123;s = s.toString(); //转换1s.hello = &quot;你好&quot;; //转换2//console.log(typeof s); //stringconsole.log(s.hello); //undefined //转换3 此时对象与转换2时不是同一个 字符串相关操作在底层字符串是以字符数组的形式保存的 length属性：获取字符串长度 方法 charAt() 可以返回字符串指定位置的字符 charCodeAt() 返回指定位置字符的Unicode编码 String.fromCharCode() 可以根据字符编码获取字符 concat() 连接字符串 indexOf() ​ 检查一个字符串中是否含有指定内容，如果有则返回第一次出现的索引，没有则返回-1 ​ 可以指定第二个参数，表示开始查找的位置 lastIndexOf() 与从后往前找 slice() 从字符串中截取指定内容，同数组slice()方法 substring() ​ 和slice()类似，不同的是此方法参数不接受负值，传递负值则默认使用0 ​ 还会自动调整参数位置，如果前大于后，则交换位置 split() ​ 可以将一个字符串拆分为一个数组 ​ 需要一个字符串作为参数，根据该字符串拆分数组 toUpperCase(), toLowerCase() 转大小写 正则表达式 创建正则表达式对象 语法：var 变量名 = new RegExp(“正则表达式”[,”匹配模式”]); 使用字面量来创建正则表达式 语法：var 变量名 = /正则表达式/匹配模式; 匹配模式： i 忽略大小写 g 全局匹配 正则表达式的方法： ​ test() 使用这个方法可以传入一个字符串来检查其是否符合正则表达式，返回布尔值 注意：使用构造函数创建正则表达式时，由于它的参数是一个字符串，而 \\ 是字符串中的转义字符，如果要使用 \\ 则需要使用 \\\\ 来代替 语法方括号用于查找某个范围内的字符 表达式 描述 [abc] 查找方括号之间的任何字符。 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。 [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [adgk] 查找给定集合内的任何字符。 [^adgk] 查找给定集合外的任何字符。 (red|blue|green) 查找任何指定的选项。 元字符元字符（Metacharacter）是拥有特殊含义的字符： 元字符 描述 . 查找单个字符，除了换行和行结束符。 \\w 查找单词字符。 \\W 查找非单词字符。 \\d 查找数字。 \\D 查找非数字字符。 \\s 查找空白字符。 \\S 查找非空白字符。 \\b 匹配单词边界。 \\B 匹配非单词边界。 \\0 查找 NUL 字符。 \\n 查找换行符。 \\f 查找换页符。 \\r 查找回车符。 \\t 查找制表符。 \\v 查找垂直制表符。 \\xxx 查找以八进制数 xxx 规定的字符。 \\xdd 查找以十六进制数 dd 规定的字符。 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 量词 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。 n* 匹配任何包含零个或多个 n 的字符串。 n? 匹配任何包含零个或一个 n 的字符串。 n{X} 匹配包含 X 个 n 的序列的字符串。 n{X,Y} 匹配包含 X 至 Y 个 n 的序列的字符串。 n{X,} 匹配包含至少 X 个 n 的序列的字符串。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。 ?=n 匹配任何其后紧接指定字符串 n 的字符串。 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串。 字符串和正则表达式相关的方法 split() 可以将字符串拆分成一个数组 可以传递一个正则表达式作为参数 不需要设置全局匹配模式 search() 可以搜索字符串中是否含有指定内容 如果搜索到则返回第一次出现的索引，没有则返回-1 可以接收一个正则表达式作为参数 只会匹配第一个，即使设置了全局匹配模式 match() 可以根据正则表达式，将内容从字符串中提取出来 默认只会找到第一个符合要求的内容，我们可以设置全局匹配模式以匹配所有内容 该方法会将匹配到的内容封装到一个数组中返回，即使只有一个结果 replace() 可以将字符串中指定内容替换为新内容 参数：1.被替换内容(可以接收正则表达式) 2.新的内容 默认只会替换第一个匹配项 将新内容设置为空串可以用于删除指定内容","categories":[{"name":"关于技术","slug":"关于技术","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"关于技术/JavaScript","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liyang1998.gitee.io/tags/JavaScript/"},{"name":"笔记","slug":"笔记","permalink":"https://liyang1998.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"知识总结","slug":"知识总结","permalink":"https://liyang1998.gitee.io/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"}]},{"title":"Vue 自定义指令实现 el-select 选项懒加载","slug":"Vue自定义指令实现el-select懒加载","date":"2021-04-21T15:36:23.000Z","updated":"2021-04-27T15:19:14.708Z","comments":true,"path":"posts/f060dab1.html","link":"","permalink":"https://liyang1998.gitee.io/posts/f060dab1.html","excerpt":"","text":"由于之前公司的项目中某个 select 选项数据量过大，想到了采用懒加载故从网上学到了这个方法，并用到了项目中，实测没什么问题，所以来分享一下很抱歉原文已经找不到了，如有侵权，请联系我删除 123456789101112131415161718192021222324252627282930// 自定义指令实现 el-select 选项懒加载&lt;template&gt; &lt;el-select v-el-select-loadmore=&quot;loadMore&quot;&gt; &lt;!-- ... --&gt; &lt;/el-select&gt;&lt;/template&gt;&lt;script&gt; // ... directives: &#123; &#x27;el-select-loadmore&#x27;: &#123; bind (el, binding) &#123; const ElSelectWrap = el.querySelector( &#x27;.el-select-dropdown .el-select-dropdown__wrap&#x27; ) ElSelectWrap.addEventListener(&#x27;scroll&#x27;, function () &#123; const loadmore = this.scrollHeight - this.scrollTop &lt;= this.clientHeight if (loadmore) &#123; binding.value() &#125; &#125;) &#125; &#125; &#125;, methods: &#123; loadMore() &#123; // ... &#125; &#125;&lt;/script&gt;","categories":[{"name":"关于技术","slug":"关于技术","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/"},{"name":"Vue","slug":"关于技术/Vue","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://liyang1998.gitee.io/tags/Vue/"},{"name":"自定义指令","slug":"自定义指令","permalink":"https://liyang1998.gitee.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"},{"name":"el-select","slug":"el-select","permalink":"https://liyang1998.gitee.io/tags/el-select/"},{"name":"懒加载","slug":"懒加载","permalink":"https://liyang1998.gitee.io/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"}]},{"title":"Hexo 文章永久链接（permalink）","slug":"hexo-post-permalink","date":"2021-04-20T08:19:55.729Z","updated":"2021-04-27T15:19:06.733Z","comments":true,"path":"/posts/my_custom_permalink.html","link":"","permalink":"https://liyang1998.gitee.io/posts/my_custom_permalink.html","excerpt":"","text":"本文主要是推荐使用 hexo-abbrlink 插件进行设置永久链接点击这里跳过废话，直接开搞 注意！！！经测试发现，permalink 必须添加 .html 后缀或者以 / 结尾，否则在你点击文章时，浏览器会由于错误识别类型默认进行下载，而非打开文章页面。 WhatHexo Docs - 永久链接（Permalinks）Hexo 在生成博客文章链接时，默认是按照年、月、日、标题格式来生成可以在 _config.yml 中的 permalink 设置，默认是 :year/:month/:day/:title _config.yml1permalink: :year/:month/:day/:title/ Why这样默认的设置会有以下几个缺点： 当我们把源文件名改掉之后，链接也会改变 如果文章标题很长，那么文章链接也会很长 如果文章名包含中文，转码后链接一串乱码，不美观 不利于SEO How指定 permalink我们可以在 Front-matter（即文件最上方以 --- 分隔的区域，用于指定个别文件的变量）中自定义每个文章的 permalink 12345678---title: 这是文章标题tags: 这是标签categories: 这是分类permalink: my_custom_permalink.html---content... 这样做会覆盖你在 _config.yml 中设置的 permalink文章链接会变为domain/my_custom_permalink.html但你需要为每篇文章都单独设置一个 permalink ，否则他还将是采用默认的设置 hexo-abbrlink 插件（推荐） 首先安装插件 1npm install hexo-abbrlink --save 修改配置文件 _config.yml _config.yml12345permalink: posts/:abbrlink.html # 也可以直接写成 /:abbrlink.html# abbrlink configabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 重新生成静态文件 12hexo cl &amp;&amp; hexo ghexo s 这样 Hexo 在生成静态文件时会按照你设定的规则给你的每一篇文章添加一个 abbrlink 属性用于生成永久链接 这样一来妈妈再也不用担心文章地址过长或者失效的问题了快去给你自己的博客搞起来吧！ Reference https://hexo.io/zh-cn/docs/permalinks https://github.com/rozbo/hexo-abbrlink https://zhuanlan.zhihu.com/p/169492685 https://blog.csdn.net/yanzi1225627/article/details/77761488","categories":[{"name":"关于博客","slug":"关于博客","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://liyang1998.gitee.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://liyang1998.gitee.io/tags/Hexo/"},{"name":"永久链接","slug":"永久链接","permalink":"https://liyang1998.gitee.io/tags/%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5/"},{"name":"permalink","slug":"permalink","permalink":"https://liyang1998.gitee.io/tags/permalink/"}]},{"title":"焕然一新的博客","slug":"焕然一新的博客","date":"2020-03-01T08:02:57.000Z","updated":"2021-04-20T08:41:27.399Z","comments":true,"path":"posts/b7541807.html","link":"","permalink":"https://liyang1998.gitee.io/posts/b7541807.html","excerpt":"","text":"发现了一款甚合我意的主题 Butterfly 快速上手主题主题下载在你 hexo 根目录下执行这行代码： git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly 更改设置安装完后修改根目录的配置文件_config.yml: 1theme: Butterfly 安装依赖 如果你没有 pug 和 stylus 渲染器，你需要先执行以下命令进行安装：​ npm install hexo-renderer-pug hexo-renderer-stylus ​ 如果你看见以下报错：​ Error: Cannot find module &#39;cheerio&#39;​ 需要安装cheerio，命令：​ npm install cheerio@0.22.0 --save 主题平滑升级为了主题的平滑升级,Butterfly 使用了 data files特性。 推荐把主题默认的配置文件_config.yml复制到 Hexo 工作目录下的source/_data/butterfly.yml，如果source/_data的目录不存在那就创建一个。 注意，如果你创建了butterfly.yml, 它将会替换主题默认配置文件_config.yml里的配置项 (不是合并而是替换), 之后你就只需要通过git pull的方式就可以平滑地升级 theme-butterfly了。 从3.3.0开始，以上方法不再支持 请改用以下方法，此方法只支持 Hexo 5.0.0 以上版本 如果已经在 source/_data/ 创建了 butterfly.yml，请记得删除掉。 把主題文件夹中的 _config.yml 复制到 Hexo 根目录，同时重新命名为 _config.butterfly.yml。 以后只需要在 _config.butterfly.yml 进行配置就行。 Hexo会自动合并 _config.yml 和 _config.butterfly.yml 里的配置，如果存在同名配置，会使用 _config.butterfly.yml 的配置，其优先级较高。 更多配置请查看Hexo和主题官方文档Butterfly 安裝文檔(一) 快速開始","categories":[{"name":"关于博客","slug":"关于博客","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://liyang1998.gitee.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://liyang1998.gitee.io/tags/Hexo/"},{"name":"Butterfly","slug":"Butterfly","permalink":"https://liyang1998.gitee.io/tags/Butterfly/"}]},{"title":"JS事件绑定自定义(兼容IE8方法)","slug":"JavaScript事件绑定问题","date":"2019-12-29T10:47:14.000Z","updated":"2021-04-27T15:16:37.913Z","comments":true,"path":"posts/aa38ac18.html","link":"","permalink":"https://liyang1998.gitee.io/posts/aa38ac18.html","excerpt":"JavaScript事件绑定常用方法 对象.事件 = 函数; 它只能同时为一个对象的一个事件绑定一个响应函数不能绑定多个，如果有多个，后面的会覆盖前面的 addEventListener() 此方法也可以为元素绑定响应函数 参数： 事件的字符串(不带on) 回调函数，事件触发时执行 是否在捕获阶段触发事件，一般都传false 使用此方法可以为一个元素的同一事件绑定多个响应函数 当事件触发时，按绑定顺序依次执行 attachEvent() IE8及以下浏览器不支持addEventListener()方法，但可以使用attachEvent()方法起到同样的效果 参数: 事件字符串(带on) 回调函数 此方法也可以绑定多个函数，不过函数执行顺序与addEventListener()相反 this问题与解决 addEventListener()中的this是绑定事件的对象attachEvent()中的this是window如果要解决兼容性问题则需要统一两个方法的this 这里我们用到了call()方法call()可以用来改变函数的this","text":"JavaScript事件绑定常用方法 对象.事件 = 函数; 它只能同时为一个对象的一个事件绑定一个响应函数不能绑定多个，如果有多个，后面的会覆盖前面的 addEventListener() 此方法也可以为元素绑定响应函数 参数： 事件的字符串(不带on) 回调函数，事件触发时执行 是否在捕获阶段触发事件，一般都传false 使用此方法可以为一个元素的同一事件绑定多个响应函数 当事件触发时，按绑定顺序依次执行 attachEvent() IE8及以下浏览器不支持addEventListener()方法，但可以使用attachEvent()方法起到同样的效果 参数: 事件字符串(带on) 回调函数 此方法也可以绑定多个函数，不过函数执行顺序与addEventListener()相反 this问题与解决 addEventListener()中的this是绑定事件的对象attachEvent()中的this是window如果要解决兼容性问题则需要统一两个方法的this 这里我们用到了call()方法call()可以用来改变函数的this 函数bind()自己定义一个函数用来给一个对象绑定事件 思路 三个参数：对象，事件，回调函数 兼容性： 通过if判断对象是否存在addEventListener方法来区分浏览器 this问题的解决 由于传入的回调函数是浏览器调用的，我们无法去操作，所以我们在attachEvent()不直接传入回调函数，而是先定义一个匿名函数，然后在函数内部调用回调函数，并利用call方法改变this 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var btn1 = document.getElementById(&quot;btn1&quot;); bind(btn1, &quot;click&quot;,function()&#123; alert(this); &#125;); &#125;; //定义一个函数bind()，用来为指定元素绑定事件响应函数 /* * 参数： * obj 要绑定事件的对象 * eventStr 事件的字符串 * func 回调函数 */ function bind(obj, eventStr, func)&#123; //判断是否有addEventListener()方法 if(obj.addEventListener)&#123; //大部分浏览器兼容的方式 obj.addEventListener(eventStr, func, false); &#125; else&#123; //IE8及以下 注意 on //obj.attachEvent(&quot;on&quot;+eventStr, func);//此方法this为window下面提供解决方法 //统一this 不直接调用func而是在匿名函数内调用 obj.attachEvent(&quot;on&quot;+eventStr, function()&#123; //在匿名函数内调用回调函数 利用call()方法将this改为obj func.call(obj); &#125;); &#125; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;btn1&quot;&gt;btn1&lt;/button&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"关于技术","slug":"关于技术","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"关于技术/JavaScript","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liyang1998.gitee.io/tags/JavaScript/"}]},{"title":"JavaScript DOM事件对象练习","slug":"JavaScriptDOM事件对象练习-学习内容分享","date":"2019-12-27T07:29:44.000Z","updated":"2021-04-27T15:16:52.785Z","comments":true,"path":"posts/5657d3d4.html","link":"","permalink":"https://liyang1998.gitee.io/posts/5657d3d4.html","excerpt":"Event 对象Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。 事件通常与函数结合使用，函数不会在事件发生前被执行！ 本文用于记录个人学习过程中的两个小练习，其中包括一些事件对象的用法和问题的解决以及兼容性问题。 获取鼠标指针坐标 div跟随鼠标移动","text":"Event 对象Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。 事件通常与函数结合使用，函数不会在事件发生前被执行！ 本文用于记录个人学习过程中的两个小练习，其中包括一些事件对象的用法和问题的解决以及兼容性问题。 获取鼠标指针坐标 div跟随鼠标移动 练习1 获取鼠标指针坐标两个div，当鼠标在上面的div#areaDiv移动时，在下面的div#showMsg中显示鼠标指针坐标 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #areaDiv&#123; width: 500px; height: 200px; border: 1px solid black; &#125; #showMsg&#123; width: 500px; height: 50px; margin-top: 20px; border: 1px solid black; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; /* * 当鼠标在areaDiv中移动时，在showMsg中显示鼠标的坐标 */ //获取div var areaDiv = document.getElementById(&quot;areaDiv&quot;); var showMsg = document.getElementById(&quot;showMsg&quot;); /* * 事件对象 * - 当事件的响应函数被触发时，浏览器会将一个事件对象作为实参传递进响应函数， * 在事件对象中封装了当前事件相关的一切信息，比如：鼠标指针的坐标，键盘哪个按键被按下 */ areaDiv.onmousemove = function(event)&#123; /* * 在IE8中，响应函数被触发时，浏览器不会传递事件对象 * 而是将事件对象作为window对象的属性保存的 window.event * 但此方法不兼容火狐 */ /*解决兼容问题，使用if判断 if(!event)&#123; event = window.event; &#125;*/ //此方法更简单方便 event = event || window.event; /* 获取坐标值 * clientX 可以获取鼠标指针的水平坐标 * clientY 可以获取鼠标指针的垂直坐标 */ var x = event.clientX; var y = event.clientY; //显示坐标值 showMsg.innerHTML = &#x27;x=&#x27;+x+&#x27; , y=&#x27;+y; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;areaDiv&quot;&gt;&lt;/div&gt; &lt;div id=&quot;showMsg&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2 div跟随鼠标移动当鼠标在页面中移动时，使div跟随其移动 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;div跟随鼠标移动&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; width:2000px; height: 1000px;&#125; /*使页面出现滚动条*/ #box1&#123; width: 100px; height: 100px; background-color: red; position: absolute; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var box1 = document.getElementById(&quot;box1&quot;); //使div可以跟随鼠标移动，响应函数加给document document.onmousemove = function(event)&#123; event = event || window.event; //获取滚动条滚动距离 var st = document.documentElement.scrollTop; var sl = document.documentElement.scrollLeft; //获取鼠标指针坐标 /* clientX、clientY * 用于获取当前可见窗口的鼠标坐标 * 而div的偏移量是相对整个页面的 * * pageX、pageY可以获取鼠标相对当前页面的坐标 * 但是不兼容IE8及以下 * * 因此我们选择获取滚动条滚动距离，将其加到div的偏移量上 */ var left = event.clientX; var top = event.clientY; //设置div偏移量 box1.style.left = left +sl+&#x27;px&#x27;; box1.style.top = top +st+&#x27;px&#x27;; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 部分内容来源于网上教程，侵删。","categories":[{"name":"关于技术","slug":"关于技术","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"关于技术/JavaScript","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liyang1998.gitee.io/tags/JavaScript/"}]},{"title":"JavaScript数组的方法","slug":"JavaScript数组的方法","date":"2019-12-18T14:50:33.000Z","updated":"2021-04-27T15:16:49.077Z","comments":true,"path":"posts/f6df6a5d.html","link":"","permalink":"https://liyang1998.gitee.io/posts/f6df6a5d.html","excerpt":"数组数组的四个常用方法push() 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新长度 可以将要添加的元素作为方法的参数传递，这些元素将会自动添加到数组的末尾 pop() 该方法可以删除数组的最后一个元素，并将被删除的元素返回 unshift() 向数组开头添加一个或多个元素，并返回新的数组长度 添加元素后，其他元素的索引会相应调整 shift() 可以删除数组的第一个元素，并将其作为返回值返回","text":"数组数组的四个常用方法push() 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新长度 可以将要添加的元素作为方法的参数传递，这些元素将会自动添加到数组的末尾 pop() 该方法可以删除数组的最后一个元素，并将被删除的元素返回 unshift() 向数组开头添加一个或多个元素，并返回新的数组长度 添加元素后，其他元素的索引会相应调整 shift() 可以删除数组的第一个元素，并将其作为返回值返回 数组的遍历 for 循环 123456var arr = [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;马六&quot;];for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[i]);&#125; forEach * 1234567891011121314151617//forEach() 不支持IE9以下浏览器var arr = [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;马六&quot;];/* * forEach()方法需要一个函数作为参数 * - 像这种函数，由我们创建但不是我们调用的，我们称之为回调函数 * - 数组中有几个元素就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式 * 传递进来，我们可以定义形参，来读取这些内容 * - 浏览器会在回调函数中传递三个参数： * 第一个参数：当前正在遍历的元素 * 第二个参数：当前正在遍历的元素的索引 * 第三个参数：当前正在遍历的数组 */arr.forEach(function(value, index, obj)&#123; console.log(value);&#125;); slice()和splice()slice() 可以用来从数组中提取指定元素 参数：截取开始的位置索引，截取结束的位置索引 (前闭后开,第二个参数可以不写，默认取到最后一个元素) 索引可以是负值 -1为最后一个元素 splice() 删除元素并向数组添加新元素 将指定元素从原数组中删除并返回 参数：第一个：开始位置索引第二个：删除的数量第三个及以后：可以传递一些新的元素，这些元素会自动插入到开始索引位置之前 数组去重123456789101112131415161718192021//创建一个数组var arr = [1,2,3,2,1,3,4,2,5];//数组去重1 //获取数组中的每一个元素（遍历）for(var i=0; i&lt;arr.length; i++)&#123; //遍历当前元素后的所有元素 for(var j=i+1; j&lt;arr.length; j++)&#123; //判断两个元素值是否相等 if(arr[i]==arr[j])&#123; //相等则证明出现重复，删除j对应元素 arr.splice(j,1); //当删除了当前j所对应元素后，后面的元素会自动补位 //导致j新对应的元素无法进行比较，如果该元素依旧重复则会遗漏 //故使j自减 j--; &#125; &#125;&#125;console.log(arr); 数组其他方法123456789101112131415161718192021222324252627282930313233343536/* 1 * concat()可以连接两个或多个数组，并将新的数组返回 * - 该方法不会对原数组产生影响 * - 参数也可以为元素 *//* 2 * join()方法可以将数组转换为一个字符串 * - 该方法不会对原数组产生影响，而是将转换后的结果返回 * - 可以指定一个字符串作为参数，它将会作为数组元素的连接符，不填则默认为&quot;,&quot; *//* 3 * reverse()方法可以用来反转数组 * - 会直接操作原数组 *//* 4 * sort()用来对数组元素进行排序 * - 改变原数组 * - 默认按照Unicode编码进行排序，即使对纯数字数组排序一会按照Unicode编码排序 * - 我们可以自己指定排序规则，在sort()添加一个回调函数 * 回调函数中需要定义两个形参 * 浏览器将会分别使用数组中的元素作为实参去调用回调函数 * - 浏览器会根据回调函数的返回值来决定元素的顺序 * 如果返回一个大于0的值，则元素交换位置 * 如果返回一个小于0的值，则元素位置不变 * 如果返回一个0，则认为两个元素相等，不交换位置 */var arr = [5,4,1,3,2];arr.sort(function(a,b)&#123; return a - b; //升序 //return b - a; //降序&#125;);","categories":[{"name":"关于技术","slug":"关于技术","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"关于技术/JavaScript","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liyang1998.gitee.io/tags/JavaScript/"}]},{"title":"JavaScript构造函数","slug":"JavaScript构造函数学习笔记分享","date":"2019-12-18T07:06:47.000Z","updated":"2021-04-27T15:16:31.442Z","comments":true,"path":"posts/dd3a73b8.html","link":"","permalink":"https://liyang1998.gitee.io/posts/dd3a73b8.html","excerpt":"构造函数构造函数就是一个普通的函数，创建方式和普通函数没有区别 不同的是构造函数名习惯上首字母大写 普通函数是直接调用，而构造函数需要使用new关键字来调用 构造函数的执行流程： 立刻创建一个新的对象 将新建的对象设置为函数中的this（在构造函数中可以使用this来引用新建的对象） 逐行执行函数中的代码 将新建的对象作为返回值返回 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类 我们将通过一个函数创建的对象，称为是该类的实例","text":"构造函数构造函数就是一个普通的函数，创建方式和普通函数没有区别 不同的是构造函数名习惯上首字母大写 普通函数是直接调用，而构造函数需要使用new关键字来调用 构造函数的执行流程： 立刻创建一个新的对象 将新建的对象设置为函数中的this（在构造函数中可以使用this来引用新建的对象） 逐行执行函数中的代码 将新建的对象作为返回值返回 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类 我们将通过一个函数创建的对象，称为是该类的实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 创建一个Person构造函数 * - 在Person构造函数中，为每一个对象都添加了一个sayName方法 * 目前我们是在构造函数内部创建方法，这就导致了构造函数每执行一次就会创建一个方法 * 而且所有实例的sayName方法都是一模一样的但却是唯一的 * - 我们完全可以使所有对象共享一个方法 */function Person(name, age, gender)&#123; this.name = name; this.age = age; this.gender = gender; //1.在构造函数内部添加方法 /*this.sayName = function()&#123; alert(&quot;大家好，我是&quot;+this.name); &#125;;*/ //this.sayName = fun; //2.将sayName方法在全局作用域中定义，而不是在构造函数内部&#125;//将sayName方法在全局作用域中定义/* * 将函数定义在全局作用域，污染了全局作用域的命名空间 * 而且定义在全局作用域中也很不安全 * 解决：原型 *///function fun()&#123;// alert(&quot;大家好，我是&quot;+this.name);//&#125;//3.向原型中添加sayName方法Person.prototype.sayName = function()&#123; alert(&quot;大家好，我是&quot;+this.name);&#125;;//创建Person类的实例var person1 = new Person(&quot;李四&quot;, 18, &quot;男&quot;);var person2 = new Person(&quot;王五&quot;, 16, &quot;女&quot;);person1.sayName();person2.sayName();//使用instanceof可以检查一个对象是否是一个类的实例//console.log(person1 instanceof Person); //true/* * 所有对象都是Object的后代 * 所以任何对象和Object作instanceof检查时都会返回true *///console.log(person1 instanceof Object); //true 原型123456789101112131415161718192021222324252627282930313233343536373839/* * 原型prototype * 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype * 这个属性对应着一个对象，这个对象就是我们所谓的原型对象 * 如果函数作为普通函数调用prototype没有任何作用 * 当函数以创造函数的形式调用时，它所创建的对象中都会有一个隐含的属性 * 指向该构造函数的原型对象，我们可以通过__proto__来访问 * * 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到 * 我们可以将对象中共有的内容，统一设置到原型对象中 * * 当我们访问对象的属性或方法时，会现在对象自身中寻找，如果有则直接使用， * 没有则去原型中寻找... 直到找到Object的原型 * Object的原型没有原型(null)，如果在Object的原型中依然没有找到，则返回undefined * * 以后我们创建构造函数时，可以将这些对象共有的属性和方法，添加到构造函数的原型对象中 */function MyClass()&#123; &#125;//向MyClass的原型中添加属性aMyClass.prototype.a = 123;//向MyClass的原型中添加方法MyClass.prototype.sayHello = function()&#123; alert(&quot;Hello&quot;);&#125;;var mc = new MyClass();var mc2 = new MyClass();mc2.a = &quot;我是mc2中的a&quot;;//console.log(MyClass.prototype);//console.log(mc.__proto__ == MyClass.prototype); //trueconsole.log(mc.a); //123console.log(mc2.a); //我是mc2中的a 1234567891011121314151617function MyClass()&#123; &#125;//向MyClass的原型中添加属性nameMyClass.prototype.name = &quot;我是原型中的名字&quot;;var mc = new MyClass();mc.age = 18;//使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true//console.log(&quot;name&quot; in mc); //true//可以使用hasOwnProperty()来检查对象自身中是否有该属性//使用该方法只有当对象自身含有该属性时，才会返回trueconsole.log(mc.hasOwnProperty(&quot;name&quot;)); //falseconsole.log(mc.hasOwnProperty(&quot;age&quot;)); //true 原文地址：博客园 https://www.cnblogs.com/meow999/p/12059917.html","categories":[{"name":"关于技术","slug":"关于技术","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"关于技术/JavaScript","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liyang1998.gitee.io/tags/JavaScript/"}]},{"title":"JavaScript 实现图片滚动","slug":"JavaScript-pic_move","date":"2019-12-10T13:13:14.000Z","updated":"2021-04-29T16:34:32.383Z","comments":true,"path":"posts/6d2ec284.html","link":"","permalink":"https://liyang1998.gitee.io/posts/6d2ec284.html","excerpt":"定时器应用：图片滚动分享一下最近学习的JavaScript定时器实现图片的无缝滚动。 间隔型定时器setInterval()与clearInterval() 12var timer = setInterval(func, delay); //第一个参数为定时器要执行的函数，第二个参数为定时器间隔，单位msclearInterval(timer); //停止定时器，参数为setInterval()所启动的定时器 原理和方法 让ul一直向左移动 –&gt; 减少left值 –&gt; offsetLeft 1oUl.style.left&#x3D;oUl.offsetLeft-1+&#39;px&#39;; 复制li 我们演示的是div宽度可以容纳4张图片，而一共有4张图，所以我们要把4张图复制一份并接到后面 innerHTML 1oUl.innerHTML+=oUl.innerHTML; 修改ul的width 原先的ul宽度足以容纳内容，所以需要重新调整否则图片将分两行显示 1oUl.style.width=aLi[0].offsetWidth*aLi.length+&#x27;px&#x27;; 过界重设位置 当ul走完半程即第一份的4张图全部走出容器时，重设ul位置，回到起点，即可实现无缝滚动 判断: 1234if(oUl.offsetLeft&lt;-oUl.offsetWidth/2)&#123; oUl.style.left=&#x27;0&#x27;;&#125;","text":"定时器应用：图片滚动分享一下最近学习的JavaScript定时器实现图片的无缝滚动。 间隔型定时器setInterval()与clearInterval() 12var timer = setInterval(func, delay); //第一个参数为定时器要执行的函数，第二个参数为定时器间隔，单位msclearInterval(timer); //停止定时器，参数为setInterval()所启动的定时器 原理和方法 让ul一直向左移动 –&gt; 减少left值 –&gt; offsetLeft 1oUl.style.left&#x3D;oUl.offsetLeft-1+&#39;px&#39;; 复制li 我们演示的是div宽度可以容纳4张图片，而一共有4张图，所以我们要把4张图复制一份并接到后面 innerHTML 1oUl.innerHTML+=oUl.innerHTML; 修改ul的width 原先的ul宽度足以容纳内容，所以需要重新调整否则图片将分两行显示 1oUl.style.width=aLi[0].offsetWidth*aLi.length+&#x27;px&#x27;; 过界重设位置 当ul走完半程即第一份的4张图全部走出容器时，重设ul位置，回到起点，即可实现无缝滚动 判断: 1234if(oUl.offsetLeft&lt;-oUl.offsetWidth/2)&#123; oUl.style.left=&#x27;0&#x27;;&#125; 图片演示 此图为初始结构示意 外层为div容器，内部为ul图片列表，4张图片，则设置div宽度等于图片宽度*4 如图，当ul向左移动后右侧没有内容进行显示，故我们进行复制li操作 （外层容器div设置overflow:hidden;属性，已经走出div范围的部分不会显示） 复制li后再进行移动则会产生如图所示效果（两侧超出内容隐藏） 当ul走完一半宽度（如图），此时显示内容原始内容相同，故我们重设ul位置，在视觉上实现无缝滚动 重设ul位置，回到初始状态 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;图片滚动&lt;/title&gt; &lt;style&gt; #div1&#123; position: relative; width: 1200px; height: 437px; margin: 100px auto; overflow: hidden; border-radius: 15px; &#125; .pic-list&#123; position: absolute; left: 0; top: 0; &#125; .pic-list li&#123; float: left; width: 300px; height: 437px; list-style: none; &#125; .pic-list img&#123; width: 300px; height: 437px; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; var oDiv=document.getElementById(&#x27;div1&#x27;); var oUl=oDiv.getElementsByClassName(&#x27;pic-list&#x27;); var aLi=oUl.getElementsByTagName(&#x27;li&#x27;); oUl.innerHTML+=oUl.innerHTML; //将图片列表复制一份接到后面，长度必须大于等于div一次可显示长度 oUl.style.width=aLi[0].offsetWidth*aLi.length+&#x27;px&#x27;; //重新设置ul宽度=一个li宽度*li个数 //图片滚动函数 function move()&#123; //if条件判断作用： //当ul走完一半的时候重新回到原点，即可实现无缝滚动 if(oUl.offsetLeft&lt;-oUl.offsetWidth/2)&#123; oUl.style.left=&#x27;0&#x27;; &#125; oUl.style.left=oUl.offsetLeft-1+&#x27;px&#x27;; //每单位时间往左移动1px &#125; var timer = setInterval(move,30); //设置定时器，间隔30ms oDiv.onmouseover=function()&#123; //鼠标移入停止滚动 clearInterval(timer); &#125;; oDiv.onmouseout=function()&#123; //鼠标移出开始滚动 timer=setInterval(move,30); &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;ul class=&quot;pic-list&quot;&gt; &lt;li&gt;&lt;img src=&quot;img/1.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;img/2.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;img/3.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;img/4.jpg&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 小结这是之前学习的利用原生JS定时器制作图片滚动效果，比较基础，做一下记录总结 初学前端，小白一枚，有问题还望指正 欢迎志同道合的小伙伴与我交流o(￣▽￣)ブ","categories":[{"name":"关于技术","slug":"关于技术","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"关于技术/JavaScript","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liyang1998.gitee.io/tags/JavaScript/"},{"name":"图片滚动","slug":"图片滚动","permalink":"https://liyang1998.gitee.io/tags/%E5%9B%BE%E7%89%87%E6%BB%9A%E5%8A%A8/"}]},{"title":"Hexo+Github个人博客搭建详细教程","slug":"Hexo-Github_blog","date":"2019-12-05T08:54:34.000Z","updated":"2021-04-23T03:05:29.226Z","comments":true,"path":"posts/acf3d1d8.html","link":"","permalink":"https://liyang1998.gitee.io/posts/acf3d1d8.html","excerpt":"概述使用Hexo搭建个人博客并利用GitHub进行部署。 很久之前就想搭建一个博客，可是也一直没有行动，最近在逛B站的时候发现一个up主（CodeSheep）的一个视频 《手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo》: https://www.bilibili.com/video/av44544186/ ，哈哈哈哈哈给他免费打个广告（虽然根本没人能看到），简直就是保姆级的教学视频，良心up主啊，真·手把手教学，大体浏览了一下以后我就坐不住了，马上起来开电脑行动！ 那在这里就简单总结一下过程和遇到的坑吧","text":"概述使用Hexo搭建个人博客并利用GitHub进行部署。 很久之前就想搭建一个博客，可是也一直没有行动，最近在逛B站的时候发现一个up主（CodeSheep）的一个视频 《手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo》: https://www.bilibili.com/video/av44544186/ ，哈哈哈哈哈给他免费打个广告（虽然根本没人能看到），简直就是保姆级的教学视频，良心up主啊，真·手把手教学，大体浏览了一下以后我就坐不住了，马上起来开电脑行动！ 那在这里就简单总结一下过程和遇到的坑吧 搭建博客博客是基于Hexo搭建的，需要Node.js、Git等支持 我用的是windows系统，而up主是在MacOS系统下操作的，其实大同小异。 安装Node.js 搜索引擎搜索Node.js或者直接访问 https://nodejs.org 下载左边那个LTS版本 下载完成后安装，使用 Node.js 官方安装程序时，请确保勾选 Add to PATH 选项（默认已勾选） 在cmd下分别输入命令行node -v和npm -v检查是否安装成功 安装Git 搜索引擎搜索git或者直接访问 https://git-scm.com/downloads 选择对应的操作系统下载 安装（在桌面或任意文件夹下右键菜单如果出现‘Git Bash Here’则说明成功） 安装cnpm（可选）由于国内镜像源速度较慢，所以先利用npm下载cnpm 在cmd中执行以下命令： npm install -g cnpm --registry=https://registry.npm.taobao.org 安装Hexo用以下命令安装hexo（没有安装cnpm则换成npm即可）： cnpm install -g hexo-cli 完成后运行hexo -v 查看版本以检查是否安装成功 开始搭建博客创建一个文件夹，例如：D:\\blog 转到此路径，然后运行hexo init进行初始化，也可以直接用hexo init D:\\blog 看到INFO Start blogging with Hexo!则说明成功 此时你会发现对应目录下已经为你自动生成了一些文件 12345678910111213C:\\WINDOWS\\system32&gt;d:D:\\&gt;cd blogD:\\blog&gt;D:\\blog&gt;hexo init或者直接C:\\WINDOWS\\system32&gt;hexo init D:\\blog...INFO Start blogging with Hexo!D:\\blog&gt; 启动只需要hexo server或者直接简写hexo s即可启动 123D:\\blog&gt;hexo sINFO Start processingINFO Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop. 看到以上提示说明启动成功，然后打开浏览器访问 http://localhost:4000 即可看到博客页面 新建文章用hexo new &quot;My New Post&quot;新建博客文章 12D:\\blog&gt;hexo new &quot;我的第一篇博客文章&quot;INFO Created: D:\\blog\\source\\_posts\\我的第一篇博客文章.md 可以看到生成的文件是.md后缀即markdown格式，你需要了解一下markdown 生成静态文件hexo generate或者hexo g 生成静态文件。 hexo s 重新启动服务器即可看到新添加的文章了。 部署博客这里我们用利用Github将博客进行免费部署。 创建Github库首先你需要有一个Github账号，然后新建一个库，库的名字为：username.github.io 注意此处username必须为你的用户名！ 安装部署插件 cnpm install --save hexo-deployer-git 更改配置文件在你的目录找到名为_config.yml的文件，用文本编辑器打开文件，找到最下面的‘deploy’项，将内容改为如下： 1234deploy: type: git repo: https://github.com/username/username.githu.io.git # 或者SSH branch: master 进行部署命令很简单只需要一行 hexo d 即可，过程会提示你输入你的 Github 的账号密码，正确输入即可。 成功提示 INFO Deployer done: git 然后刷新你的仓库你会发现多了很多东西 访问博客地址部署完成后访问username.github.io 如果出问题的话将 Git 与 Github 的用户名改为一致后重试 1234567891011查看用户名和邮箱地址：git config user.namegit config user.email修改用户名和邮箱地址:git config --global user.name &quot;xxxx&quot;git config --global user.email &quot;xxxx&quot; 更换主题请看这篇文章：焕然一新的博客","categories":[{"name":"关于博客","slug":"关于博客","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://liyang1998.gitee.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://liyang1998.gitee.io/tags/Hexo/"}]}],"categories":[{"name":"关于技术","slug":"关于技术","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"关于技术/JavaScript","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/"},{"name":"Vue","slug":"关于技术/Vue","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/Vue/"},{"name":"关于博客","slug":"关于博客","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liyang1998.gitee.io/tags/JavaScript/"},{"name":"笔记","slug":"笔记","permalink":"https://liyang1998.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"知识总结","slug":"知识总结","permalink":"https://liyang1998.gitee.io/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"name":"Vue","slug":"Vue","permalink":"https://liyang1998.gitee.io/tags/Vue/"},{"name":"自定义指令","slug":"自定义指令","permalink":"https://liyang1998.gitee.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"},{"name":"el-select","slug":"el-select","permalink":"https://liyang1998.gitee.io/tags/el-select/"},{"name":"懒加载","slug":"懒加载","permalink":"https://liyang1998.gitee.io/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"},{"name":"博客","slug":"博客","permalink":"https://liyang1998.gitee.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://liyang1998.gitee.io/tags/Hexo/"},{"name":"永久链接","slug":"永久链接","permalink":"https://liyang1998.gitee.io/tags/%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5/"},{"name":"permalink","slug":"permalink","permalink":"https://liyang1998.gitee.io/tags/permalink/"},{"name":"Butterfly","slug":"Butterfly","permalink":"https://liyang1998.gitee.io/tags/Butterfly/"},{"name":"图片滚动","slug":"图片滚动","permalink":"https://liyang1998.gitee.io/tags/%E5%9B%BE%E7%89%87%E6%BB%9A%E5%8A%A8/"}]}