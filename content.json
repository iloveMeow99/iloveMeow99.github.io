{"meta":{"title":"Yangyang's Blog","subtitle":"","description":" Yangyyang 的个人博客，框架 Hexo，主题 Butterfly。Yangyang —— 李洋，一个前端，会点 Vue，博客主要用来做笔记，记录学习，分享技巧。","author":"Yangyang","url":"https://liyang1998.gitee.io","root":"/"},"pages":[{"title":"","date":"2021-05-10T06:01:11.640Z","updated":"2021-04-29T04:09:41.000Z","comments":true,"path":"baidupush.js","permalink":"https://liyang1998.gitee.io/baidupush.js","excerpt":"","text":"(function () { var bp = document.createElement(\"script\"); var curProtocol = window.location.protocol.split(\":\")[0]; if (curProtocol === \"https\") { bp.src = \"https://zz.bdstatic.com/linksubmit/push.js\"; } else { bp.src = \"http://push.zhanzhang.baidu.com/push.js\"; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })();"},{"title":"分类","date":"2020-02-26T12:45:57.000Z","updated":"2021-04-28T14:55:31.000Z","comments":false,"path":"categories/index.html","permalink":"https://liyang1998.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"Ordinary but unique","date":"2020-02-27T08:30:12.000Z","updated":"2021-04-12T08:03:22.000Z","comments":false,"path":"about/index.html","permalink":"https://liyang1998.gitee.io/about/index.html","excerpt":"","text":".title p{ font-size: 20px;} .content{ padding-left: 15px; font-size: 16px;} 关于我 Yangyang 一个前端 喜欢音乐、游戏 关于博客 本博客是基于Hexo搭建的，主题为Butterfly"},{"title":"留下足迹","date":"2020-02-26T12:49:17.000Z","updated":"2021-04-21T14:10:30.000Z","comments":true,"path":"messageboard/index.html","permalink":"https://liyang1998.gitee.io/messageboard/index.html","excerpt":"","text":"有什么想说的 有什么想问的 有什么想吐槽的 在下面留言告诉我吧"},{"title":"热爱生活，热爱音乐","date":"2020-02-26T12:54:38.000Z","updated":"2021-04-06T03:41:55.000Z","comments":true,"path":"music/index.html","permalink":"https://liyang1998.gitee.io/music/index.html","excerpt":"","text":"IU var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":0,\"mode\":\"random\",\"mutex\":true,\"theme\":\"#e6d0b2\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"삐삐 - (BBIBBI)\",\"author\":\"IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=1316563427\",\"pic\":\"https://pic.xiami.net/images/album/img14/196/5bbdc4a4491bc_9841114_1539163300.jpg?x-oss-process=image/quality,q_80/format,jpg\"},{\"title\":\"Blueming\",\"author\":\"IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=1404511131\",\"pic\":\"https://pic.xiami.net/images/album/img67/13/5dd25f4b8247f_679267_1574068043.jpg?x-oss-process=image/quality,q_80/format,jpg\"},{\"title\":\"Love poem\",\"author\":\"IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=1400436688\",\"pic\":\"https://pic.xiami.net/images/album/img9/60/5dbbf5e4db403_3020209_1572599268.jpg?x-oss-process=image/quality,q_80/format,jpg\"},{\"title\":\"囍帖街 (Live)\",\"author\":\"IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=35847131\",\"pic\":\"https://pic.xiami.net/images/album/img22/56822/21003906211474253302.jpeg?x-oss-process=image/quality,q_80/format,jpg\"},{\"title\":\"봄 사랑 벚꽃 말고 (除了春天 爱情和樱花)\",\"author\":\"High4 / IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=28391219\",\"pic\":\"https://pic.xiami.net/images/album/img82/1895391682/2970987581402380352.jpg?x-oss-process=image/quality,q_80/format,jpg\"}]}; options.element = document.getElementById(\"aplayer-mwFbzhfZ\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);"},{"title":"标签","date":"2020-02-26T12:44:18.000Z","updated":"2021-04-28T14:55:20.000Z","comments":false,"path":"tags/index.html","permalink":"https://liyang1998.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-02-26T12:46:50.000Z","updated":"2021-04-02T01:54:56.000Z","comments":true,"path":"link/index.html","permalink":"https://liyang1998.gitee.io/link/index.html","excerpt":"","text":""}],"posts":[{"title":"用原生 JS 写一个贪吃蛇","slug":"用原生-JS-写一个贪吃蛇","date":"2021-05-12T16:00:29.000Z","updated":"2021-05-13T07:53:30.555Z","comments":true,"path":"posts/2bb7f68c.html","link":"","permalink":"https://liyang1998.gitee.io/posts/2bb7f68c.html","excerpt":"","text":"Greedy Snake 贪吃蛇基于原生 js 采用面向对象编程思想 部分 ES6+ 语法 效果展示演示地址 思路整理Classes 节点 Node: 用于创建蛇身体每一部分的组成元素，以及食物。 x: 水平位置y: 垂直位置type: head / body / foodel: 每个 node 实例都对应一个 DOM 元素，实际上就是一个个 div 小方块，每个方块在容器内部进行绝对定位，有对应的 top 和 left 值 蛇 Snake:存储蛇相关信息，处理移动等逻辑。 游戏 Game:用于存储游戏信息和控制游戏整体逻辑，初始化、开始、暂停、结束等。 核心原理 移动的实现： 关于蛇的移动的实现，我们不采用去修改每个元素对应的 top 和 left 的方法，因为当蛇达到一定长度时，每一步移动我们都要去修改很多 DOM 元素，这样做效率低而且性能也不好。 其实我们每次移动只需要考虑蛇头和蛇尾就可以了，当蛇移动时，生成一个新头，添加到身体最前端，然后弹出最后一个元素（即尾部），这样不断进行变化，就实现了蛇的移动；如果在移动过程中碰到了食物，则不需要删除当前蛇尾元素，这样则实现了蛇长度的增长。 食物的生成： while 循环获取容器内部随机的 x, y 值，当得到第一个不与蛇身体重合的位置时停下。 碰撞： 即两个 node 之间位置重合（碰到身体、食物）或者超出一定范围（碰到墙壁/出界），通过简单判断 x, y 即可实现。 代码实现详见源码: https://gitee.com/liyang1998/GreedySnake https://github.com/ly980408/GreedySnake","categories":[{"name":"关于技术","slug":"关于技术","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"关于技术/JavaScript","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/"},{"name":"游戏","slug":"关于技术/JavaScript/游戏","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liyang1998.gitee.io/tags/JavaScript/"},{"name":"JS游戏","slug":"JS游戏","permalink":"https://liyang1998.gitee.io/tags/JS%E6%B8%B8%E6%88%8F/"},{"name":"H5游戏","slug":"H5游戏","permalink":"https://liyang1998.gitee.io/tags/H5%E6%B8%B8%E6%88%8F/"},{"name":"面向对象","slug":"面向对象","permalink":"https://liyang1998.gitee.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"贪吃蛇","slug":"贪吃蛇","permalink":"https://liyang1998.gitee.io/tags/%E8%B4%AA%E5%90%83%E8%9B%87/"}]},{"title":"ES6 知识梳理","slug":"ES6-知识梳理","date":"2021-04-30T06:30:08.000Z","updated":"2021-04-30T06:59:49.000Z","comments":true,"path":"posts/fbce3249.html","link":"","permalink":"https://liyang1998.gitee.io/posts/fbce3249.html","excerpt":"","text":"ES6 —— 从一脸懵逼到灵活运用本文为笔者学习 ES6 时自用的知识梳理笔记，如有错误，欢迎指出～ var let constvar let const 的比较声明与赋值 var声明的变量是可以重新赋值的，也可以重复声明 let和const声明的变量都是不可以重复声明的 ​ 在不同作用域内可以出现同名变量，但并不相同，只能在各自的作用域中使用 不同的是， let声明的变量是可以重新赋值的，但 const不行 ​ 注意：用const声明的变量并不是完全不可以改变的 ​ 如果用const来声明一个对象，虽然无法给这个对象重新赋值，但是我们可以改变对象的属性值（对象是引 用类型变量，只改变对象的属性并不会影响指针指向） ​ 如果你也不希望改变属性值的话可以使用Object.freeze()方法 变量作用域 var 为 function scope 即函数作用域 在函数中声明的变量只能在函数中使用 如果在在if和for等语句里定义的变量你只希望在内部使用，var就无法满足，因为它没有在函数里声明，所以会变成一个全局变量，污染全局作用域 let 和 const 是 block scope 即块级作用域 一对大括号 { } 所包裹的内容即为一个块级作用域，声明的变量只能在块内使用，在块级作用域外调用则会报错 let 和 const 的使用场景 用let和const代替 IIFE IIFE 即 立即执行函数 ，应用之一就用来生成一个私有变量 1234567891011121314// 例如我们在window对象中有一个name属性，如果直接这样声明一个name变量的话会覆盖属性name的值// var name = &#x27;Tom&#x27;;// 我们通常会用一个立即执行函数来使变量私有化(function () &#123; var name = &#x27;Tom&#x27;; // do something&#125;)();// 如果使用 let 或者 const 就可以简单实现，只需要用一对大括号包裹起来，就形成了一个块级作用域&#123; let name = &#x27;Tom&#x27;; // do something&#125; for 循环 1234567891011121314for (var i = 0; i &lt; 10; i++) &#123; console.log(i); // 输出：0 1 2 3 ... 9 // 我们这里用setTimeout来模拟异步请求 setTimeout(function() &#123; console.log(&#x27;i:&#x27; + i); // 这里输出了10个 i:10 // 因为函数是延迟一秒执行的 此时 for 循环已经结束 &#125;, 1000)&#125;// 将 var 改成 let 即可得到想要的结果// 注意：不能使用 const ！ … 临时性死区 Temporal Dead Zone变量提升是指 JavaScript 将变量的声明移至作用域的顶部 12345678910console.log(color); // 不会报错 而是输出 undefinedvar color = &#x27;yellow&#x27;;// 因为有了变量提升实际上这段代码是这样的var color;console.log(color); // 所以这里会输出 undefinedcolor = &#x27;yellow&#x27;;// 如果将 var 换成 let 则会报 ReferenceError 在 ES6 中， let 也会将变量提升到块级作用域顶部，但你想在块级作用域中变量的声明之前引用的话就会报ReferenceError， 因为它是在临时性死区中的， const 亦是如此需要注意的是，因为 const 定义的是一个常量，所以声明的同时必须赋初始值，否则会报错 使用建议 默认使用 const 当变量需要重新赋值时使用 let 尽量不使用 var Arrow Function 箭头函数优点： 简明的语法 可以隐式返回 不绑定this 简明的语法例如我们要用 map 遍历一个数组使其中的数乘以二返回 1234567891011121314const nums = [1, 3, 0, 5];const double = nums.map(function (num) &#123; return num * 2;&#125;);console.log(double); // [2, 6, 0, 10]// 改用箭头函数 const double2 = nums.map((num) =&gt; &#123; return num * 2;&#125;);console.log(double2); // [2, 6, 0, 10] 箭头函数写法：去掉function关键字，加上 =&gt; 如果箭头函数只有一个参数的话，()可以省略，没有参数或者有多个参数则必须使用括号并且参数之间用,隔开 隐式返回显式返回即return关键字加上返回的内容。 箭头函数中的隐式返回： ​ 去掉return关键字 ， 去掉 &#123;&#125; ， 将表达式写到一行中 用于我们只想简单返回一些内容时使用，使代码更加简洁 12// like thisconst double3 = nums.map((num) =&gt; num * 2); 注： 因为箭头函数都是匿名函数，匿名函数在递归或者作为回调函数等场景时非常好用，但如果你只想作为一个简单函数的话我们一般把它赋值给一个变量来使用 this问题在使用箭头函数以前我们经常遇到这样的问题 1234567891011121314151617const Tom = &#123; name: &#x27;Tom&#x27;, hobbies: [&#x27;Coding&#x27;, &#x27;Sleeping&#x27;, &#x27;Reading&#x27;], showHobbies: function () &#123; this.hobbies.forEach(function (hobby) &#123; console.log(this.name + &#x27; likes &#x27; + hobby); &#125;) &#125;&#125;Tom.showHobbies(); /* 输出： likes Coding likes Coding likes Reading 咦，你会发现 Tom 不见了，看来是 this.name 的 this 指向出了问题*/ 这里的showHobbies()是由 对象Tom调用的，所以this指向的是对象Tom，因此 this.hobbies 可以正常取到； 而forEach()方法里的回调函数他不是作为对象的方法调用，也没有使用apply、call等方法来改变this指向，所以这里的this指向的是 Window 或者说全局（严格模式下为undefined） 以前我们通常的做法是在这之前var self = this;，然后用self代替this来使用 在ES6中我们可以借助箭头函数来代替这种 hack 写法，因为箭头函数没有自己的this，它的this值是继承它的父级作用域的（词法作用域，由上下文确定） 箭头函数不适用的场景 作为构造函数，向原型对象中添加方法 当你真的需要this的时候，例如事件绑定 需要使用arguments对象时 参数默认值1234567891011// 直接定义在函数的形参后面function multiply (a, b = 1) &#123; return a * b;&#125;multiply(); // NaNmultiply(3); // 3multiply(3, 5); // 15// 传入 null 并不会使用默认值multiply(5, null); // 0 模板字符串在过去我们要组合 变量 和 字符串 的时候需要不停地用+进行连接，这样既繁琐又容易出错而且不易检查。 有了 ES6 的模板字符串就变得容易多了 模板字符串 允许我们用一对反引号 ` 来定义字符串 $&#123;&#125; 里面可以是任意的 JS 表达式，包括对象的属性，甚至是一个函数 123456const name = &#x27;Tom&#x27;;const age = 5;const text = `$&#123;name&#125; is $&#123;age * 5&#125; years old.`;console.log(text); // &quot;Tom is 25 years old.&quot; New String Methods12345678910111213141516171819202122232425262728const id = &#x27;adcd123456x&#x27;;const fan = &#x27;I love ES6.&#x27;// .startsWith()// 检查字符串是否以xx开头，返回布尔值，第二个参数传入开始位置索引，不传默认为0，大小写敏感id.startsWith(&#x27;abc&#x27;); // trueid.startsWith(&#x27;123&#x27;, 5);// truefan.startsWith(&#x27;I&#x27;); // truefan.startsWith(&#x27;i&#x27;); // false// .endsWith()// 检查字符串是否以xx结尾，返回布尔值，第二个参数传入结尾位置索引，不传默认为最后，大小写敏感id.endsWith(&#x27;x&#x27;); // trueid.endsWith(&#x27;X&#x27;); // falsefan.endsWith(&#x27;love&#x27;, 6); // true// .includes()// 检查子字符串是否包含于字符串中，返回布尔值，可以传入第二个参数，指定匹配开始位置索引，大小写敏感fan.indexOf(&#x27;ES6&#x27;) !== -1; // truefan.includes(&#x27;ES6&#x27;); // true// .repeat()// 将字符串重复n次，参数为重复次数( &gt;=0 ) 解构对象解构12345678910111213141516171819202122232425262728293031323334353637const Tom = &#123; name: &#x27;Tom Jones&#x27;, age: 25, family: &#123; mother: &#x27;Norah Jones&#x27;, father: &#x27;Richard Jones&#x27;, brother: &#x27;Howard Jones&#x27; &#125;&#125;// 1. without destructuring// const name = Tom.name;// const age = Tom.age;// ...// 2. with destructuring// 这行语句的意思：先声明变量 name 和 age ，然后在 Tom 对象中寻找同名属性，找到把属性值后赋值给变量const &#123; name, age &#125; = Tom;console.log(name); // &#x27;Tom Jones&#x27;console.log(age); // 25// 如果你想要赋值给已经声明的变量 将语句用()包裹起来// 因为如果不加 () 的话，解析器会把 &#123; &#125; 内的内容解析成一个代码块，而不是解构语法// let name = &#x27;&#x27;;// (&#123; name, age &#125; = Tom);// 对象解构中还允许对变量进行重命名// 比如 father 变量名已经被提前占用，下面语法中把 father 重新命名成了 dad// 如果我们去获取一个对象没有的属性时，则会返回 undefined // 当然也允许我们传入一个默认值，但只有在当对象该属性的值为 undefined 时才会使用默认值，null false 等不行const father = &quot;Tom&#x27;s Dad&quot;;const &#123; father: dad, son, sister = &#x27;no sister&#x27; &#125; = Tom.family;console.log(dad); // &#x27;Richard Jones&#x27;console.log(son); // undefinedconsole.log(sister); // &#x27;no sister&#x27; 数组解构1234567891011121314151617181920const numbers = [1, 2, 3, 4, 5]// 获取相对应位置的值const [one, two] = numbersconsole.log(one, two) // 1 2// 像这样用逗号隔开可以跳过某个索引位置const [yi, , san] = numbersconsole.log(yi, san) // 1 3// 如果变量数量多余数组的值的话 多余的会被赋值 undefined ，// 同样，我们也可以提供默认值， 当值为绝对的(===) undefined 时会使用默认值// 还有一种写法 ...others 会将剩余的内容保存到一个数组里const [first, ...others] = numbersconsole.log(first, others) // 1 [2, 3, 4, 5]// ... + 变量名 是 rest参数 ， 后面我们再介绍// 注意它只能出现在数组的最后面，否则会报错 以前我们要交换两个变量的值的时候，经常会定义一个中间变量，有了解构赋值我们就可以方便的进行交换了 12345678910111213let a = 10let b = 20// 引入中间变量let temptemp = aa = bb = tempconsole.log(a, b) // 20 10// 解构赋值[a, b] = [b, a]console.log(a, b) // 10 20 for of 循环for of 是ES6新增的一种循环方式 123456789101112131415161718192021222324252627282930313233343536const fruits = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;orange&#x27;, &#x27;mango&#x27;]// 我们在遍历一个数组的时候， 常常有这几种方法：// 1. for 循环 - 这种方式既繁琐可读性又差for (let i = 0; i &lt; fruits.length; i++) &#123; console.log(fruits[i])&#125;// 2. 数组的 forEach() 方法 - 简化了for循环，而且可以有新的变量名 fruit，但此方法无法中止或跳出循环fruits.forEach(fruit =&gt; &#123; console.log(fruit)&#125;)// 3. for in 循环 - for (let fruit in fruits) &#123; console.log(fruit) // 0 1 2 3 : for in 循环的值是属性名而不是属性值，所以在遍历数组是返回的是索引值&#125;for (let index in fruits) &#123; console.log(fruits[index]) // apple banana orange mango&#125;// 但是还有一个问题，for in 循环遍历的是对象上的所以可枚举属性， 即使你是加在原型对象上// 比如我们给 fruits 加一个属性，这时候再去遍历输出， 你会发现输出多了个 My favorit fruits // for in 更适合用来遍历对象，不适合用来遍历数组fruits.description = &#x27;My favorit fruits&#x27;for (let index in fruits) &#123; console.log(fruits[index]) // apple banana orange mango My favorit fruits&#125;// 为了解决以上几种方法的缺陷 ES6 引入了新的循环方法 for of// 它解决了 for in 遍历内容为属性名 和 会遍历数组的非数字属性 的问题// 而且相对 forEach() 方法而言，它还支持循环中止和跳过for (let fruit of fruits) &#123; console.log(fruit) // apple banana orange mango&#125; New Array Methods.from() &amp; .of()这两个方法并不是原型上的方法，需要通过 Array 对象来调用，即Array.from()和 Array.of() Array.from()用于把一个类数组或者可遍历对象转换为一个真正的数组， 同时它还支持传入回调函数作为第二个参数 ，来对转换成的数组每一项执行一定的方法进行处理 Array.of()主要解决Array()构造函数传入不同数量的参数时行为不一致的问题： ​ 当你传入一个参数(例如：2)时，它会返回长度为2的数组(undefined x 2)，当你传入多个参数(例如：1,2,3)，这时它又会返回由这些参数组成的数组 而Array.of()无论你传入多少个参数，它都会返回由这些参数组成的数组 其他方法.find() .findIndex() .some() .every() find()方法用于返回数组中满足条件（函数内判断）的第一个元素的值 当数组中的元素在符合条件时返回，之后的值不会再调用执行函数 如果没有符合条件的元素则返回 undefined 语法：array.find(function(element, index, arr)) 参数：测试函数 function(element, index, arr) ​ element - 当前元素 ​ index - 当前元素索引 ​ arr - 正在执行该方法的数组 123456// 例如我们想要从ages数组中得到年龄大于等于18的第一个元素const ages = [3, 10, 17, 20]const res = ages.find((age) =&gt; &#123; return age &gt;= 18&#125;)console.log(res) // 18 findIndex()方法与find()方法类似，唯一不同就是它返回的是满足条件的元素的索引值 some()和every()用法类似，只不过返回的是一个布尔值 ​ 前者表示至少有一个满足，即找到一个满足条件的元素时返回true ​ 后者表示每一个都满足，即当所有元素都满足条件时才会返回true，当找到一个不满足条件的元素时就会立即返回false 剩余参数剩余参数语法允许我们将一个不定数量的参数表示为一个数组 当我们定义一个函数的时候，如果在最后一个参数前面加...前缀，就会将剩余参数存到一个数组中 语法： 123function(a, b, ...theArgs) &#123; // ...&#125; 12345678910// 比如我们定义一个函数来计算商品的折后价// 第一个参数传入的是折扣 后面的参数为商品原价// 这里我们就可以用到剩余参数啦，将价格存到一个数组中去function discount(rate, ...prcies) &#123; // 因为prices是一个数组，所以我们可以直接调用 map 方法 return prices.map((price) =&gt; price * rate)&#125;const discountPrices = discount(0.8, 100, 150, 1000)console.log(discountPrices) // [80, 120, 800] 前面我们提到过，剩余参数还以用于变量的解构 1234// 我们定义一个变量来记录玩家的 name id 和 scores// 利用剩余参数我们就可以方便的将分数都保存到一个数组里面const player = [&#x27;Tom&#x27;, 123456, 5.6, 7.3, 3,4, 8.9]const [name, id, ...scores] = player 扩展运算符（…）扩展运算符用法与剩余参数相反，它用于把可遍历对象的元素扩展为一个新的参数序列 1234// 把一个字符串中的每一个字符存到一个数组中const name = &#x27;Iverson&#x27;const arr = [...name]console.log(arr) // [&quot;I&quot;, &quot;v&quot;, &quot;e&quot;, &quot;r&quot;, &quot;s&quot;, &quot;o&quot;, &quot;n&quot;] 1234567// 把两个数组进行拼接可以用 concat 方法，但如果我们还要在两个数组的元素中间加入一个元素，就不太方便了// 这时候扩展运算符就出来拯救我们了const youngers = [&#x27;George&#x27;, &#x27;John&#x27;, &#x27;Thomas&#x27;]const olders = [&#x27;James&#x27;, &#x27;Adrew&#x27;, &#x27;Martin&#x27;]const members = [...youngers, &#x27;Mary&#x27;, ...olders]console.log(members) // [&quot;George&quot;, &quot;John&quot;, &quot;Thomas&quot;, &quot;Mary&quot;, &quot;James&quot;, &quot;Adrew&quot;, &quot;Martin&quot;] 对象字面量的扩展当我们在声明一个对象的时候，如果属性名和属性值所指向的变量名一致，可以简化书写 12345678910111213141516const name = &#x27;Tom&#x27;const age = 20const gender = &#x27;男&#x27;const Tom = &#123; name, // =&gt; name: name, age, // =&gt; age: age, gender // =&gt; gender: gender // 对象的方法也同样可以简写 /* getAge: function () &#123; alert(`I&#x27;m $&#123;this.name&#125;`) &#125; */ getAge () &#123; alert(`I&#x27;m $&#123;this.name&#125;`) &#125;&#125; ES6还提供了计算属性，你可以在对象的属性名和属性值处写入 js 语句 12345678910const keys = [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;gender&#x27;]const values = [&#x27;Tom&#x27;, 20, &#x27;男&#x27;]const Tom = &#123; [keys.shift()]: values.shift(), [keys.shift()]: values.shift(), [keys.shift()]: values.shift()&#125;console.log(Tom) // &#123;name: &quot;Tom&quot;, age: 20, gender: &quot;男&quot;&#125; Promise以下内容来自于 MDN Web文档， 查看更多 因为大部分情况下我们只是使用已创建的 Promise 实例对象，所以此处只简单介绍用法，要想了解Promise构造函数，点击此处 Promise 是一个对象，它代表了一个异步操作的最终完成或者失败。 本质上，Promise 是一个被某些函数传出的对象，我们附加回调函数（callback）使用它，而不是将回调函数传入那些函数内部。 约定 不同于“老式”的传入回调，在使用 Promise 时，会有以下约定： 在 本轮 Javascript event loop（事件循环）运行完成 之前，回调函数是不会被调用的。 通过 then() 添加的回调函数总会被调用，即便它是在异步操作完成之后才被添加的函数。 通过多次调用 then()，可以添加多个回调函数，它们会按照插入顺序一个接一个独立执行。 因此，Promise 最直接的好处就是链式调用（chaining）。 链式调用在过去，要想做多重的异步操作，会导致经典的回调地狱： 1234567doSomething(function(result) &#123; doSomethingElse(result, function(newResult) &#123; doThirdThing(newResult, function(finalResult) &#123; console.log(&#x27;Got the final result: &#x27; + finalResult); &#125;, failureCallback); &#125;, failureCallback);&#125;, failureCallback); 通过新的功能方法，我们把回调绑定到被返回的 Promise 上代替以往的做法，形成一个 Promise 链： 12345678910doSomething().then(function(result) &#123; return doSomethingElse(result);&#125;).then(function(newResult) &#123; return doThirdThing(newResult);&#125;).then(function(finalResult) &#123; console.log(&#x27;Got the final result: &#x27; + finalResult);&#125;).catch(failureCallback); then里的参数是可选的，catch(failureCallback) 是 then(null, failureCallback) 的缩略形式。如下所示，我们也可以用箭头函数来表示： 1234567doSomething().then(result =&gt; doSomethingElse(result)).then(newResult =&gt; doThirdThing(newResult)).then(finalResult =&gt; &#123; console.log(`Got the final result: $&#123;finalResult&#125;`);&#125;).catch(failureCallback); Symbol symbol 是ES6新加的一种基本数据类型。 Symbol()函数会返回symbol类型的值，但它并不是构造函数，因为它不支持语法：new Symbol()。 每个从Symbol()返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符，这是该数据类型仅有的目的。 语法： Symbol([description]) description 为可选参数，字符串类型，是对 symbol 的描述 123const sym1 = Symbol()const sym2 = Symbol(&#x27;foo&#x27;)const sym3 = Symbol(&#x27;foo&#x27;) 上面的代码创建了三个新的symbol类型。 它们每一个都会是新的 symbol 类型，即使用了同样的描述： 1Symbol(&quot;foo&quot;) === Symbol(&quot;foo&quot;) // false 使用 new 运算符的语法将抛出 TypeError 错误： 1const sym = new Symbol() // TypeError Symbols 在 for...in 循环中不可枚举。另外，Object.getOwnPropertyNames() 也不会返回 symbol 类型的属性，但是你能使用 Object.getOwnPropertySymbols() 得到它们 Modules (模块)导出模块 export 命名导出 named exports 为了获得模块的功能要做的第一件事是把它们导出来。使用 export 语句来完成。 最简单的方法是把它（指export语句）放到你想要导出的项前面，比如： 12345export const name = &#x27;square&#x27;export function funcName() &#123; // ...&#125; 你能够导出函数，var，let，const, 和类。export要放在最外层；比如你不能够在函数内使用export。 一个更方便的方法导出所有你想要导出的模块的方法是在模块文件的末尾使用一个export 语句， 用花括号括起来你想导出的模块并用逗号分割。比如： export &#123; name, age, func1, func2 &#125; 此方式还支持你对导出的模块使用as进行重命名： export &#123; name as n, age as a, func1, func2 &#125; 这样在你导入的时候就需要使用as后的变量名进行导入 默认导出 default export 上面方法导出的功能都是由 named exports 组成 — 每个项目（无论是函数，常量等）在导出时都由其名称引用，并且该名称也用于在导入时引用它。 还有一种导出类型叫做 default export 语法：export default xxx ，xxx 为你要导出的项目的名字 ​ 我们还可以把 export default 放到函数或者类的前面： ​ export default function() &#123;&#125; ​ export default class &#123;&#125; 注意，不能使用 var、let 或 const 用于导出默认值 export default。 关于两种导出方式 你能够在每一个模块中定义多个命名导出，但是只允许有一个默认导出。在导出多个值时，命名导出非常有用。在导入期间，必须使用相应对象的相同名称。但是，你可以使用任何名称导入默认导出的模块。 导入模块 import语法： 12345import defaultExport from &quot;module-name&quot;import * as name from &quot;module-name&quot;import &#123; export &#125; from &quot;module-name&quot;import &#123; export as alias &#125; from &quot;module-name&quot;import &#123; export1 , export2 &#125; from &quot;module-name&quot; defaultExport 导入默认导出时的的引用名 module-name 要导入的模块。通常是包含目标模块的.JavaScript文件的相对或绝对路径名，可以不包括.JavaScript扩展名。 name 导入模块对象整体的别名 export, export1, export2 被导入模块的导出接口的名称 ( 命名导出，导入时需使用相同的名称 ) alias 用于引用指定导入的名称 ( 同导出时，导入时也可以使用 as 进行重命名 ) Class ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。 基本语法12345678910111213141516171819202122232425// 传统方法 通过构造函数定义并生成一个新的对象function Person (name, age) &#123; this.name = name this.age = age&#125;// 向原型对象中添加方法Person.prototype.sayName = function () &#123; console.log(`My name is $&#123;this.name&#125;`)&#125;// 创造实例const p1 = new Person(&#x27;Tom&#x27;, 21)// ===========================================// 定义类class Person &#123; constructor(x, y) &#123; this.x = x this.y = y &#125; sayName() &#123; console.log(`My name is $&#123;this.name&#125;`) &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Person，对应ES6的Person类的构造方法。 Person类除了构造方法，还定义了一个sayName方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ES6的类，完全可以看作构造函数的另一种写法。 123456class Person &#123; // ...&#125;typeof Person // &quot;function&quot;Person === Person.prototype.constructor // true 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。 构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。在类的实例上面调用方法，其实就是调用原型上的方法。 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。 12345678910class Person &#123; constructor()&#123; // ... &#125;&#125;Object.assign(Person.prototype, &#123; sayName()&#123;&#125;, sayAge()&#123;&#125;&#125;) 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 支持计算属性：类的属性名，可以采用表达式。 1234567891011121314let methodName = &#x27;greet&#x27;class MyClass &#123; constructor()&#123; // ... &#125; [methodName] () &#123; console.log(&#x27;Hello&#x27;) &#125;&#125;const class1 = new MyClass()class1.greet() // &quot;Hello&quot; constructor方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo// false 类的实例对象生成类的实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。 与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 12345678910111213141516171819202122//定义类class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; sayName() &#123; console.log(`My name is $&#123;this.name&#125;`) &#125;&#125;var person = new Person(&#x27;Tom&#x27;, 21);person.sayName() // My name is Tomperson.hasOwnProperty(&#x27;name&#x27;) // trueperson.hasOwnProperty(&#x27;age&#x27;) // trueperson.hasOwnProperty(&#x27;sayName&#x27;) // falseperson.__proto__.hasOwnProperty(&#x27;sayName&#x27;) // true 类的所有实例共享一个原型对象。 12345var p1 = new Person(&#x27;Tom&#x27;,21);var p2 = new Person(&#x27;Jerry&#x27;,20);p1.__proto__ === p2.__proto__//true 上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。 这也意味着，可以通过实例的__proto__属性为Class添加方法。 不存在变量提升Class不存在变量提升（hoist），这一点与ES5完全不同。 Class 表达式与函数一样，类也可以使用表达式的形式定义。 12345const MyClass = class Me &#123; getClassName() &#123; return Me.name &#125;&#125; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。 123let inst = new MyClass()inst.getClassName() // MeMe.name // ReferenceError: Me is not defined 上面代码表示，Me只在Class内部有定义。 如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。 1const MyClass = class &#123; /* ... */ &#125; 采用Class表达式，可以写出立即执行的Class。 1234567891011let person = new class &#123; constructor(name) &#123; this.name = name &#125; sayName() &#123; console.log(this.name) &#125;&#125;(&#x27;张三&#x27;)person.sayName() // &quot;张三&quot; 上面代码中，person是一个立即执行的类的实例。 静态方法静态方法就是直接定义在构造函数上的方法，例如 Array.from()和 Array.of()，只能通过构造函数 Array 来调用，而不能通过实例进行调用。 在 class 类中，我们通过static关键字来定义一个静态方法 1234567891011121314class MyClass() &#123; constructor() &#123; // ... &#125; static func()&#123; console.log(&#x27;I am a static method&#x27;) &#125;&#125;const class1 = new MyClass()MyClass.func() // &quot;I am a static method&quot;class1.func() // error getter 和 setter在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return &#x27;getter&#x27; &#125; set prop(value) &#123; console.log(&#x27;setter: &#x27;+value) &#125;&#125;const inst = new MyClass()inst.prop = 123;// setter: 123inst.prop// &#x27;getter&#x27; class 的继承Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。 1class Cat extends Pet &#123;&#125; 上面代码定义了一个Cat类，该类通过extends关键字，继承了Pet类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Pet类。下面，我们在Cat内部加上代码。 123456789101112131415161718192021class Pet &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; greet() &#123; console.log(&#x27;Hello&#x27;) &#125;&#125;class Cat extends Pet &#123; constructor(name, age, food) &#123; super(name, age); this.food = &#x27;fish&#x27; &#125; greet() &#123; console.log(&#x27;Meow~&#x27;) &#125;&#125; 上面代码中，constructor方法中出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 子类Cat的greet方法覆盖了父类中的greet方法 迭代器和生成器 处理集合中的每个项是很常见的操作。JavaScript 提供了许多迭代集合的方法，从简单的 for循环到 map() 和 filter()。迭代器和生成器将迭代的概念直接带入核心语言，并提供了一种机制来自定义 for...of 循环的行为。 Proxy Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。 语法 let p = new Proxy(target, handler); 参数: target 用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 handler 一个对象，其属性是当执行一个操作时定义代理的行为的函数。 Reflect- SetES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成Set数据结构。 语法new Set([iterable]); 参数 iterable 如果传递一个可迭代对象，它的所有元素将不重复地被添加到新的 Set 中。如果不指定此参数或其值为null，则新的 Set 为空。 返回值 一个新的Set对象。 值的相等向 Set 加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===）。NaN和undefined都可以被存储在Set 中， NaN之间被视为相同的值（不同于精确相等）。 由于对象为引用数据类型，两个空对象不相等，所以它们被视为两个值。 属性和方法Set 的实例对象有以下属性： Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set 的实例对象的方法： add(value)：向尾部添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 key方法、value方法、entries方法返回的都是遍历器对象（详见Iterator对象）。由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以key方法和value方法的行为完全一致。 entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。 Set 的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。 Set.prototype[Symbol.iterator] === Set.prototype.values 这意味着，可以省略values方法，直接用for...of循环遍历Set。 forEach方法，用于对每个成员执行某种操作，没有返回值。 参数是一个处理函数，该函数的参数依次为 键值、键名、集合自身。另外，forEach方法还可以传入第二个参数，表示绑定的 this 对象。 扩展运算符 (...) 可用于 Set 结构，两者结合使用，可以用来去除数组重复成员： 123let arr = [3, 5, 2, 2, 5, 5]let unique = [...new Set(arr)]// [3, 5, 2] WeakSet语法1new WeakSet([iterable]); 参数 iterable 如果传入一个可迭代对象作为参数, 则该对象的所有迭代值都会被自动添加进生成的 WeakSet 对象中。null 被认为是 undefined。 描述WeakSet 对象是一些对象值的集合, 并且其中的每个对象值都只能出现一次。在WeakSet的集合中是唯一的 它和 Set 对象的区别有两点: 与Set相比，WeakSet 只能是对象的集合，而不能是任何类型的任意值。 WeakSet持弱引用：集合中对象的引用为弱引用。 如果没有其他的对WeakSet中对象的引用，那么这些对象会被当成垃圾回收掉。 这也意味着WeakSet中没有存储当前对象的列表。 正因为这样，WeakSet 是不可枚举的。 方法 WeakSet.prototype.add(value) 在该 WeakSet 对象中添加一个新元素 value. WeakSet.prototype.delete(value) 从该 WeakSet 对象中删除 value这个元素, 之后 WeakSet.prototype.has(value) 方法便会返回 false. WeakSet.prototype.has(value) 返回一个布尔值, 表示给定的值 value 是否存在于这个 WeakSet 中. Map- 参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScripthttps://es6.ruanyifeng.com/","categories":[{"name":"关于技术","slug":"关于技术","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"关于技术/JavaScript","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/"},{"name":"ES6","slug":"关于技术/JavaScript/ES6","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/ES6/"}],"tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"https://liyang1998.gitee.io/tags/JavaScirpt/"},{"name":"ES6","slug":"ES6","permalink":"https://liyang1998.gitee.io/tags/ES6/"},{"name":"解构","slug":"解构","permalink":"https://liyang1998.gitee.io/tags/%E8%A7%A3%E6%9E%84/"},{"name":"扩展运算符","slug":"扩展运算符","permalink":"https://liyang1998.gitee.io/tags/%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/"}]},{"title":"JavaScript 基础知识总结","slug":"JavaScript-一些基础知识总结","date":"2021-04-29T16:14:17.000Z","updated":"2021-04-29T16:40:50.000Z","comments":true,"path":"posts/e5b43a6.html","link":"","permalink":"https://liyang1998.gitee.io/posts/e5b43a6.html","excerpt":"","text":"文章内容为本人在最初学习 JS 时整理的笔记由于技术有限，知识点较为基础，也稍微有些杂乱如有错误，欢迎指出 输入输出123prompt(); //弹出输入框alert(); //弹出提示框console.log(); //浏览器控制台打印 变量声明、赋值和变量的初始化12345var a; //声明a = 5; //赋值var b = 10; //初始化b = 20; //重新赋值var x=1,y=2,z=3; //同时声明多个变量，可以只写一个var，中间用‘,’隔开 特殊情况 只声明 不赋值 -&gt; undefined 不声明 不赋值 -&gt; 使用时会报错 不声明直接赋值 -&gt; 可以使用 变量命名规范 由字母、数字、下划线、美元符号$组成 严格区分大小写 不能以数字开头 不能是关键字、保留字 变量名必须有意义 遵守驼峰命名法 数据类型 typeof -&gt; 返回数据类型 基本数据类型 Number 数字 Boolean 布尔值 String 字符串 undefined 未定义 null 空值 （ES6新增） Symbol 唯一标识符 引用数据类型 Object 对象 基本和引用类型的区别 JS中的变量都是保存到栈内存中的 基本数据类型的值直接在栈内存中存储 值与值之间是独立存在的，修改一个变量不会影响其他变量 对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间 而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用，当通过一个变量修改属性时，另一个也会受到影响 当比较两个基本数据类型时，就是比较它们的值 当比较两个引用数据类型时，比较的是对象的内存地址 两个对象即使一模一样，如果地址不同，也会返回false 数据类型转换 转换为字符串 变量.toString() String(变量) 强制转换 ‘+’拼接字符串(隐式转换，推荐) 转换为数字型 parseInt(string) 函数 将string类型转成整型 parseFloat(string) 函数 将string类型转成浮点型 Number() 强制转换函数 将string类型转成数字型 隐式转换 利用算术运算符隐式转换 转换为布尔型 Boolean() 函数：代表空、否定的值都会被转换为false。 对象和函数对象的分类 内建对象 由ES标准中定义的对象，在任何ES的实现中都可以使用 比如： Math String Number Boolean Function Object 宿主对象 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象比如 BOM DOM 自定义对象 由开发人员自己创建的对象 作用域 作用域指一个变量的作用范围 在JS中一共有两种作用域： 全局作用域 直接编写在script标签中的JS代码，都在全局作用域 全局作用域在页面打开时创建，在页面关闭时销毁 在全局作用域中有一个全局对象window它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用 在全局作用域中：创建的变量都会作为window对象的属性保存创建的函数都会作为window对象的方法保存 全局作用域中的变量都是全局变量，在页面的任意部分都可以访问到 函数作用域 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁 没调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的 在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量 当在函数作用域中操作变量时，现在自身作用域中寻找，如果有就直接使用，没有则去上一级作用域中寻找 this解析器在调用函数时会向函数内部传递一个隐含的参数，这个隐含的参数就是this， this指向的是一个对象，这个对象我们称为为函数执行的上下文对象， 根据函数的调用方式的不同，this会指向不同的对象， 主要有以下几个场景： 以函数的形式调用时，this永远都是window 以方法的形式调用时，this就是调用方法的那个对象 以构造函数的形式调用时，this就是新创建的那个对象 使用call和apply调用时，this是传入的那个对象 构造函数构造函数本质上就是一个普通的函数，创建方式和普通函数没有区别 构造函数命名上习惯首字母大写 构造函数需要使用new关键字来调用 构造函数的执行流程： 立刻创建一个新的对象 将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象 逐行执行函数中的代码 将新建的对象作为返回值返回 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类 我们将通过一个函数创建的对象，称为是该类的实例 this的情况： 当以函数的形式调用时，this就是window 当以方法的形式调用时，谁调用方法谁就是this 当以构造函数的形式调用时，this就是新创建的那个对象12345678910111213141516171819202122232425262728293031323334353637383940414243/* 创建一个Person构造函数 * - 在Person构造函数中，为每一个对象都添加了一个sayName方法 * 目前我们是在构造函数内部创建方法，这就导致了构造函数每执行一次就会创建一个方法 * 而且所有实例的sayName方法都是一模一样的但却是唯一的 * - 我们完全可以使所有对象共享一个方法 */function Person(name, age, gender)&#123; this.name = name; this.age = age; this.gender = gender; /*this.sayName = function()&#123; alert(&quot;大家好，我是&quot;+this.name); &#125;;*/ //将sayName方法在全局作用域中定义，而不是在内部创建 this.sayName = fun;&#125;//将sayName方法在全局作用域中定义/* * 将函数定义在全局作用域，污染了全局作用域的命名空间 * 而且定义在全局作用域中也很不安全 * 解决：原型 */function fun()&#123; alert(&quot;大家好，我是&quot;+this.name);&#125;//创建Person类的实例var person1 = new Person(&quot;李四&quot;, 18, &quot;男&quot;);var person2 = new Person(&quot;王五&quot;, 16, &quot;女&quot;);person1.sayName();person2.sayName();//使用instanceof可以检查一个对象是否是一个类的实例//console.log(person1 instanceof Person); //true/* * 所有对象都是Object的后代 * 所以任何对象和Object作instanceof检查时都会返回true *///console.log(person1 instanceof Object); //true 原型 函数 prototype 属性 ==》 原型对象 （显式原型） ​ 在定义函数时自动添加的，默认值是一个空的Object实例对象(Object例外) 实例 _proto_ 属性 ==》 原型对象 （隐式原型） ​ 在创建对象时自动添加的，默认值为构造函数的prototype属性值 ​ 即实例对象的隐式原型的值为其对应的构造函数显式原型的值 ​ 我们能直接操作显式原型，但不能操作隐式原型 原型对象 constructor 属性 ==》 函数对象 所有函数的 _proto_ 都是一样的(都是由构造函数Function创建的实例，包括Function本身） Object的原型对象是原型链的尽头(Object.prototype._proto_ == null) 123456789101112131415161718192021222324252627282930313233343536373839/* * 原型prototype * 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype * 这个属性对应着一个对象，这个对象就是我们所谓的原型对象 * 如果函数作为普通函数调用prototype没有任何作用 * 当函数以创造函数的形式调用时，它所创建的对象中都会有一个隐含的属性 * 指向该构造函数的原型对象，我们可以通过__proto__来访问 * * 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到 * 我们可以将对象中共有的内容，统一设置到原型对象中 * * 当我们访问对象的属性或方法时，会现在对象自身中寻找，如果有则直接使用， * 没有则去原型中寻找... 直到找到Object的原型 * Object的原型没有原型(null)，如果在Object的原型中依然没有找到，则返回undefined * * 以后我们创建构造函数时，可以将这些对象共有的属性和方法，添加到构造函数的原型对象中 */function MyClass()&#123; &#125;//向MyClass的原型中添加属性aMyClass.prototype.a = 123;//向MyClass的原型中添加方法MyClass.prototype.sayHello = function()&#123; alert(&quot;Hello&quot;);&#125;;var mc = new MyClass();var mc2 = new MyClass();mc2.a = &quot;我是mc2中的a&quot;;//console.log(MyClass.prototype);//console.log(mc.__proto__ == MyClass.prototype); //trueconsole.log(mc.a); //123console.log(mc2.a); //我是mc2中的a 1234567891011121314151617function MyClass()&#123; &#125;//向MyClass的原型中添加属性nameMyClass.prototype.name = &quot;我是原型中的名字&quot;;var mc = new MyClass();mc.age = 18;//使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true//console.log(&quot;name&quot; in mc); //true//可以使用hasOwnProperty()来检查对象自身中是否有该属性//使用该方法只有当对象自身含有该属性时，才会返回trueconsole.log(mc.hasOwnProperty(&quot;name&quot;)); //falseconsole.log(mc.hasOwnProperty(&quot;age&quot;)); //true IIFEImmediately-Invoked Function Expression 立即调用函数表达式、 123456789//匿名函数自调用(function ()&#123; console.log(&quot;IIFE&quot;);&#125;)();/* 作用： * 隐藏实现 * 不会污染外部命名空间 */ instanceof 表达式 A instanceof B 如果B函数的显式原型对象在A对象的原型链上，则返回true 函数的方法12345678910111213141516171819202122232425262728293031323334353637function fun()&#123; alert(this); &#125;/* * call()和apply() * - 这两个方法都是函数对象的方法，需要通过函数对象来调用 * - 当对函数调用call()和apply()都会调用函数执行 * - 在调用call()和apply()时可以将一个对象指定为第一个参数 * 这个对象将会成为函数执行时的this */fun; //[object window]fun.call(); //[object Object]fun.apply(); //[object Object]/*============================================== - call()方法可以将实参在对象之后依次传递 - apply()方法需要将实参封装到一个数组中统一传递 ==============================================*/ function fun(a, b)&#123; console.log(&quot;a = &quot;+a); console.log(&quot;b = &quot;+b);&#125;var obj = &#123; name: &quot;obj&quot;, sayName: function()&#123; alert(this.name); &#125;&#125;;fun.call(obj); //a = undefined b = undefinedfun.call(obj, 2, 3);//a = 2 b = 3fun.apply(obj, [2,3]); this的情况 以函数的形式调用时，this永远都是window 以方法的形式调用时，this就是调用方法的那个对象 以构造函数的形式调用时，this就是新创建的那个对象 使用call和apply调用时，this是指的那个对象 arguments1234567891011/* * 在调用函数时，浏览器每次都会传递进两个隐含的参数： * 1.函数的上下文对线this * 2.封装实参的对象arguments * - arguments是一个类数组对象，它也可以通过索引来操作，也可以获取长度 * - 在调用函数时，我们所传递的参数都会在arguments中保存 * - arguments.length可以用来获取实参的数量 * - 即使不定义形参也可以通过arguments来使用实参 * - arguments里面有一个属性叫做callee * 这个属性对应的就是当前正在执行的函数对象 */ Date对象123456789101112131415161718192021222324//创建一个Date对象//如果直接使用构造函数创建Date对象，则会封装为当前代码执行的时间var d = new Date();//创建一个指定的Date对象//需要在构造函数中传递一个表示时间的字符串作为参数//日期格式 月/日/年 时:分:秒var myDate = new Date(&quot;12/25/2019 12:25:00&quot;);console.log(myDate); //Wed Dec 25 2019 12:25:00 GMT+0800 (中国标准时间)/*========================================================= 方法： getDate() 获取一个月中的某一天(今天是几号? 1-31) getDay() 获取一周中的某一天(今天是周几? 0-6,0表示周日) getMonth() 获取一年中的某月(0-11) ... getTime() 获取当前日期对象的时间戳 - 时间戳：从格林威治时间的1970年1月1日 0分0时0秒 到当前日期的毫秒数 - 计算机底层保存时间使用的是时间戳=========================================================*/ Math对象Math和其他对象不同，它不是一个构造函数，它属于一个工具类，不用创建对象，它里面封装了数学运算相关的属性和方法 属性 E,LN2,LN10,PI … 方法 abs(),sqrt(),max(),min() … ceil() 向上取整 floor() 向下取整 round() 四舍五入 random() 生成一个0-1之间的随机数 12//生成一个x-y之间的随机数Math.round(Math.random()*(y-x)+x); 数组数组的四个常用方法push() 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新长度 可以将要添加的元素作为方法的参数传递，这些元素将会自动添加到数组的末尾 pop() 该方法可以删除数组的最后一个元素，并将被删除的元素返回 unshift() 向数组开头添加一个或多个元素，并返回新的数组长度 添加元素后，其他元素的索引会相应调整 shift() 可以删除数组的第一个元素，并将其作为返回值返回 数组的遍历 for 循环 123456var arr = [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;马六&quot;];for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[i]);&#125; forEach * 1234567891011121314151617//forEach() 不支持IE9以下浏览器var arr = [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;马六&quot;];/* * forEach()方法需要一个函数作为参数 * - 像这种函数，由我们创建但不是我们调用的，我们称之为回调函数 * - 数组中有几个元素就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式 * 传递进来，我们可以定义形参，来读取这些内容 * - 浏览器会在回调函数中传递三个参数： * 第一个参数：当前正在遍历的元素 * 第二个参数：当前正在遍历的元素的索引 * 第三个参数：当前正在遍历的数组 */arr.forEach(function(value, index, obj)&#123; console.log(value);&#125;); slice()和splice()slice() 可以用来从数组中提取指定元素 参数：截取开始的位置索引，截取结束的位置索引 (前闭后开,第二个参数可以不写，默认取到最后一个元素) 索引可以是负值 -1为最后一个元素 splice() 删除元素并向数组添加新元素 将指定元素从原数组中删除并返回 参数：第一个：开始位置索引第二个：删除的数量第三个及以后：可以传递一些新的元素，这些元素会自动插入到开始索引位置之前 数组去重123456789101112131415161718192021//创建一个数组var arr = [1,2,3,2,1,3,4,2,5];//数组去重1 //获取数组中的每一个元素（遍历）for(var i=0; i&lt;arr.length; i++)&#123; //遍历当前元素后的所有元素 for(var j=i+1; j&lt;arr.length; j++)&#123; //判断两个元素值是否相等 if(arr[i]==arr[j])&#123; //相等则证明出现重复，删除j对应元素 arr.splice(j,1); //当删除了当前j所对应元素后，后面的元素会自动补位 //导致j新对应的元素无法进行比较，如果该元素依旧重复则会遗漏 //故使j自减 j--; &#125; &#125;&#125;console.log(arr); 数组其他方法123456789101112131415161718192021222324252627282930313233343536/* 1 * concat()可以连接两个或多个数组，并将新的数组返回 * - 该方法不会对原数组产生影响 * - 参数也可以为元素 *//* 2 * join()方法可以将数组转换为一个字符串 * - 该方法不会对原数组产生影响，而是将转换后的结果返回 * - 可以指定一个字符串作为参数，它将会作为数组元素的连接符，不填则默认为&quot;,&quot; *//* 3 * reverse()方法可以用来反转数组 * - 会直接操作原数组 *//* 4 * sort()用来对数组元素进行排序 * - 改变原数组 * - 默认按照Unicode编码进行排序，即使对纯数字数组排序一会按照Unicode编码排序 * - 我们可以自己指定排序规则，在sort()添加一个回调函数 * 回调函数中需要定义两个形参 * 浏览器将会分别使用数组中的元素作为实参去调用回调函数 * - 浏览器会根据回调函数的返回值来决定元素的顺序 * 如果返回一个大于0的值，则元素交换位置 * 如果返回一个小于0的值，则元素位置不变 * 如果返回一个0，则认为两个元素相等，不交换位置 */var arr = [5,4];arr.sort(function(a,b)&#123; return a - b; //升序 //return b - a; //降序&#125;); 包装类在JS中为我们提供了三个包装类，通过包装类可以将基本数据类型转换为对象 String() Number() Boolean() 但是我们在实际应用中不会使用基本数据类型的对象。 方法和属性只能添加给对象，不能添加给基本数据类型 当我们对一些基本数据类型去调用属性和方法时 浏览器会临时使用包装类将其转换为对象，然后再调用属性和方法 12345678var s = 123;s = s.toString(); //转换1s.hello = &quot;你好&quot;; //转换2//console.log(typeof s); //stringconsole.log(s.hello); //undefined //转换3 此时对象与转换2时不是同一个 字符串相关操作在底层字符串是以字符数组的形式保存的 length属性：获取字符串长度 方法 charAt() 可以返回字符串指定位置的字符 charCodeAt() 返回指定位置字符的Unicode编码 String.fromCharCode() 可以根据字符编码获取字符 concat() 连接字符串 indexOf() ​ 检查一个字符串中是否含有指定内容，如果有则返回第一次出现的索引，没有则返回-1 ​ 可以指定第二个参数，表示开始查找的位置 lastIndexOf() 与从后往前找 slice() 从字符串中截取指定内容，同数组slice()方法 substring() ​ 和slice()类似，不同的是此方法参数不接受负值，传递负值则默认使用0 ​ 还会自动调整参数位置，如果前大于后，则交换位置 split() ​ 可以将一个字符串拆分为一个数组 ​ 需要一个字符串作为参数，根据该字符串拆分数组 toUpperCase(), toLowerCase() 转大小写 正则表达式 创建正则表达式对象 语法：var 变量名 = new RegExp(“正则表达式”[,”匹配模式”]); 使用字面量来创建正则表达式 语法：var 变量名 = /正则表达式/匹配模式; 匹配模式： i 忽略大小写 g 全局匹配 正则表达式的方法： ​ test() 使用这个方法可以传入一个字符串来检查其是否符合正则表达式，返回布尔值 注意：使用构造函数创建正则表达式时，由于它的参数是一个字符串，而 \\ 是字符串中的转义字符，如果要使用 \\ 则需要使用 \\\\ 来代替 语法方括号用于查找某个范围内的字符 表达式 描述 [abc] 查找方括号之间的任何字符。 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。 [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [adgk] 查找给定集合内的任何字符。 [^adgk] 查找给定集合外的任何字符。 (red|blue|green) 查找任何指定的选项。 元字符元字符（Metacharacter）是拥有特殊含义的字符： 元字符 描述 . 查找单个字符，除了换行和行结束符。 \\w 查找单词字符。 \\W 查找非单词字符。 \\d 查找数字。 \\D 查找非数字字符。 \\s 查找空白字符。 \\S 查找非空白字符。 \\b 匹配单词边界。 \\B 匹配非单词边界。 \\0 查找 NUL 字符。 \\n 查找换行符。 \\f 查找换页符。 \\r 查找回车符。 \\t 查找制表符。 \\v 查找垂直制表符。 \\xxx 查找以八进制数 xxx 规定的字符。 \\xdd 查找以十六进制数 dd 规定的字符。 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 量词 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。 n* 匹配任何包含零个或多个 n 的字符串。 n? 匹配任何包含零个或一个 n 的字符串。 n{X} 匹配包含 X 个 n 的序列的字符串。 n{X,Y} 匹配包含 X 至 Y 个 n 的序列的字符串。 n{X,} 匹配包含至少 X 个 n 的序列的字符串。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。 ?=n 匹配任何其后紧接指定字符串 n 的字符串。 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串。 字符串和正则表达式相关的方法 split() 可以将字符串拆分成一个数组 可以传递一个正则表达式作为参数 不需要设置全局匹配模式 search() 可以搜索字符串中是否含有指定内容 如果搜索到则返回第一次出现的索引，没有则返回-1 可以接收一个正则表达式作为参数 只会匹配第一个，即使设置了全局匹配模式 match() 可以根据正则表达式，将内容从字符串中提取出来 默认只会找到第一个符合要求的内容，我们可以设置全局匹配模式以匹配所有内容 该方法会将匹配到的内容封装到一个数组中返回，即使只有一个结果 replace() 可以将字符串中指定内容替换为新内容 参数：1.被替换内容(可以接收正则表达式) 2.新的内容 默认只会替换第一个匹配项 将新内容设置为空串可以用于删除指定内容","categories":[{"name":"关于技术","slug":"关于技术","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"关于技术/JavaScript","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liyang1998.gitee.io/tags/JavaScript/"},{"name":"笔记","slug":"笔记","permalink":"https://liyang1998.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"知识总结","slug":"知识总结","permalink":"https://liyang1998.gitee.io/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"}]},{"title":"Hexo 文章永久链接（permalink）","slug":"hexo-post-permalink","date":"2021-04-27T15:19:06.000Z","updated":"2021-04-27T15:19:06.000Z","comments":true,"path":"/posts/my_custom_permalink.html","link":"","permalink":"https://liyang1998.gitee.io/posts/my_custom_permalink.html","excerpt":"","text":"本文主要是推荐使用 hexo-abbrlink 插件进行设置永久链接点击这里跳过废话，直接开搞 注意！！！经测试发现，permalink 必须添加 .html 后缀或者以 / 结尾，否则在你点击文章时，浏览器会由于错误识别类型默认进行下载，而非打开文章页面。 WhatHexo Docs - 永久链接（Permalinks）Hexo 在生成博客文章链接时，默认是按照年、月、日、标题格式来生成可以在 _config.yml 中的 permalink 设置，默认是 :year/:month/:day/:title _config.yml1permalink: :year/:month/:day/:title/ Why这样默认的设置会有以下几个缺点： 当我们把源文件名改掉之后，链接也会改变 如果文章标题很长，那么文章链接也会很长 如果文章名包含中文，转码后链接一串乱码，不美观 不利于SEO How指定 permalink我们可以在 Front-matter（即文件最上方以 --- 分隔的区域，用于指定个别文件的变量）中自定义每个文章的 permalink 12345678---title: 这是文章标题tags: 这是标签categories: 这是分类permalink: my_custom_permalink.html---content... 这样做会覆盖你在 _config.yml 中设置的 permalink文章链接会变为domain/my_custom_permalink.html但你需要为每篇文章都单独设置一个 permalink ，否则他还将是采用默认的设置 hexo-abbrlink 插件（推荐） 首先安装插件 1npm install hexo-abbrlink --save 修改配置文件 _config.yml _config.yml12345permalink: posts/:abbrlink.html # 也可以直接写成 /:abbrlink.html# abbrlink configabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 重新生成静态文件 12hexo cl &amp;&amp; hexo ghexo s 这样 Hexo 在生成静态文件时会按照你设定的规则给你的每一篇文章添加一个 abbrlink 属性用于生成永久链接 这样一来妈妈再也不用担心文章地址过长或者失效的问题了快去给你自己的博客搞起来吧！ Reference https://hexo.io/zh-cn/docs/permalinks https://github.com/rozbo/hexo-abbrlink https://zhuanlan.zhihu.com/p/169492685 https://blog.csdn.net/yanzi1225627/article/details/77761488","categories":[{"name":"关于博客","slug":"关于博客","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://liyang1998.gitee.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://liyang1998.gitee.io/tags/Hexo/"},{"name":"永久链接","slug":"永久链接","permalink":"https://liyang1998.gitee.io/tags/%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5/"},{"name":"permalink","slug":"permalink","permalink":"https://liyang1998.gitee.io/tags/permalink/"}]},{"title":"Vue 自定义指令实现 el-select 选项懒加载","slug":"Vue自定义指令实现el-select懒加载","date":"2021-04-21T15:36:23.000Z","updated":"2021-04-27T15:19:14.000Z","comments":true,"path":"posts/f060dab1.html","link":"","permalink":"https://liyang1998.gitee.io/posts/f060dab1.html","excerpt":"","text":"由于之前公司的项目中某个 select 选项数据量过大，想到了采用懒加载故从网上学到了这个方法，并用到了项目中，实测没什么问题，所以来分享一下很抱歉原文已经找不到了，如有侵权，请联系我删除 123456789101112131415161718192021222324252627282930// 自定义指令实现 el-select 选项懒加载&lt;template&gt; &lt;el-select v-el-select-loadmore=&quot;loadMore&quot;&gt; &lt;!-- ... --&gt; &lt;/el-select&gt;&lt;/template&gt;&lt;script&gt; // ... directives: &#123; &#x27;el-select-loadmore&#x27;: &#123; bind (el, binding) &#123; const ElSelectWrap = el.querySelector( &#x27;.el-select-dropdown .el-select-dropdown__wrap&#x27; ) ElSelectWrap.addEventListener(&#x27;scroll&#x27;, function () &#123; const loadmore = this.scrollHeight - this.scrollTop &lt;= this.clientHeight if (loadmore) &#123; binding.value() &#125; &#125;) &#125; &#125; &#125;, methods: &#123; loadMore() &#123; // ... &#125; &#125;&lt;/script&gt;","categories":[{"name":"关于技术","slug":"关于技术","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/"},{"name":"Vue","slug":"关于技术/Vue","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://liyang1998.gitee.io/tags/Vue/"},{"name":"自定义指令","slug":"自定义指令","permalink":"https://liyang1998.gitee.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"},{"name":"el-select","slug":"el-select","permalink":"https://liyang1998.gitee.io/tags/el-select/"},{"name":"懒加载","slug":"懒加载","permalink":"https://liyang1998.gitee.io/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"}]},{"title":"焕然一新的博客","slug":"焕然一新的博客","date":"2020-03-01T08:02:57.000Z","updated":"2021-04-20T08:41:27.000Z","comments":true,"path":"posts/b7541807.html","link":"","permalink":"https://liyang1998.gitee.io/posts/b7541807.html","excerpt":"","text":"发现了一款甚合我意的主题 Butterfly 快速上手主题主题下载在你 hexo 根目录下执行这行代码： git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly 更改设置安装完后修改根目录的配置文件_config.yml: 1theme: Butterfly 安装依赖 如果你没有 pug 和 stylus 渲染器，你需要先执行以下命令进行安装：​ npm install hexo-renderer-pug hexo-renderer-stylus ​ 如果你看见以下报错：​ Error: Cannot find module &#39;cheerio&#39;​ 需要安装cheerio，命令：​ npm install cheerio@0.22.0 --save 主题平滑升级为了主题的平滑升级,Butterfly 使用了 data files特性。 推荐把主题默认的配置文件_config.yml复制到 Hexo 工作目录下的source/_data/butterfly.yml，如果source/_data的目录不存在那就创建一个。 注意，如果你创建了butterfly.yml, 它将会替换主题默认配置文件_config.yml里的配置项 (不是合并而是替换), 之后你就只需要通过git pull的方式就可以平滑地升级 theme-butterfly了。 从3.3.0开始，以上方法不再支持 请改用以下方法，此方法只支持 Hexo 5.0.0 以上版本 如果已经在 source/_data/ 创建了 butterfly.yml，请记得删除掉。 把主題文件夹中的 _config.yml 复制到 Hexo 根目录，同时重新命名为 _config.butterfly.yml。 以后只需要在 _config.butterfly.yml 进行配置就行。 Hexo会自动合并 _config.yml 和 _config.butterfly.yml 里的配置，如果存在同名配置，会使用 _config.butterfly.yml 的配置，其优先级较高。 更多配置请查看Hexo和主题官方文档Butterfly 安裝文檔(一) 快速開始","categories":[{"name":"关于博客","slug":"关于博客","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://liyang1998.gitee.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://liyang1998.gitee.io/tags/Hexo/"},{"name":"Butterfly","slug":"Butterfly","permalink":"https://liyang1998.gitee.io/tags/Butterfly/"}]},{"title":"JS事件绑定自定义(兼容IE8方法)","slug":"JavaScript事件绑定问题","date":"2019-12-29T10:47:14.000Z","updated":"2021-04-27T15:16:37.000Z","comments":true,"path":"posts/aa38ac18.html","link":"","permalink":"https://liyang1998.gitee.io/posts/aa38ac18.html","excerpt":"JavaScript事件绑定常用方法 对象.事件 = 函数; 它只能同时为一个对象的一个事件绑定一个响应函数不能绑定多个，如果有多个，后面的会覆盖前面的 addEventListener() 此方法也可以为元素绑定响应函数 参数： 事件的字符串(不带on) 回调函数，事件触发时执行 是否在捕获阶段触发事件，一般都传false 使用此方法可以为一个元素的同一事件绑定多个响应函数 当事件触发时，按绑定顺序依次执行 attachEvent() IE8及以下浏览器不支持addEventListener()方法，但可以使用attachEvent()方法起到同样的效果 参数: 事件字符串(带on) 回调函数 此方法也可以绑定多个函数，不过函数执行顺序与addEventListener()相反 this问题与解决 addEventListener()中的this是绑定事件的对象attachEvent()中的this是window如果要解决兼容性问题则需要统一两个方法的this 这里我们用到了call()方法call()可以用来改变函数的this","text":"JavaScript事件绑定常用方法 对象.事件 = 函数; 它只能同时为一个对象的一个事件绑定一个响应函数不能绑定多个，如果有多个，后面的会覆盖前面的 addEventListener() 此方法也可以为元素绑定响应函数 参数： 事件的字符串(不带on) 回调函数，事件触发时执行 是否在捕获阶段触发事件，一般都传false 使用此方法可以为一个元素的同一事件绑定多个响应函数 当事件触发时，按绑定顺序依次执行 attachEvent() IE8及以下浏览器不支持addEventListener()方法，但可以使用attachEvent()方法起到同样的效果 参数: 事件字符串(带on) 回调函数 此方法也可以绑定多个函数，不过函数执行顺序与addEventListener()相反 this问题与解决 addEventListener()中的this是绑定事件的对象attachEvent()中的this是window如果要解决兼容性问题则需要统一两个方法的this 这里我们用到了call()方法call()可以用来改变函数的this 函数bind()自己定义一个函数用来给一个对象绑定事件 思路 三个参数：对象，事件，回调函数 兼容性： 通过if判断对象是否存在addEventListener方法来区分浏览器 this问题的解决 由于传入的回调函数是浏览器调用的，我们无法去操作，所以我们在attachEvent()不直接传入回调函数，而是先定义一个匿名函数，然后在函数内部调用回调函数，并利用call方法改变this 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var btn1 = document.getElementById(&quot;btn1&quot;); bind(btn1, &quot;click&quot;,function()&#123; alert(this); &#125;); &#125;; //定义一个函数bind()，用来为指定元素绑定事件响应函数 /* * 参数： * obj 要绑定事件的对象 * eventStr 事件的字符串 * func 回调函数 */ function bind(obj, eventStr, func)&#123; //判断是否有addEventListener()方法 if(obj.addEventListener)&#123; //大部分浏览器兼容的方式 obj.addEventListener(eventStr, func, false); &#125; else&#123; //IE8及以下 注意 on //obj.attachEvent(&quot;on&quot;+eventStr, func);//此方法this为window下面提供解决方法 //统一this 不直接调用func而是在匿名函数内调用 obj.attachEvent(&quot;on&quot;+eventStr, function()&#123; //在匿名函数内调用回调函数 利用call()方法将this改为obj func.call(obj); &#125;); &#125; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;btn1&quot;&gt;btn1&lt;/button&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"关于技术","slug":"关于技术","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"关于技术/JavaScript","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liyang1998.gitee.io/tags/JavaScript/"}]},{"title":"JavaScript DOM事件对象练习","slug":"JavaScriptDOM事件对象练习-学习内容分享","date":"2019-12-27T07:29:44.000Z","updated":"2021-04-27T15:16:52.000Z","comments":true,"path":"posts/5657d3d4.html","link":"","permalink":"https://liyang1998.gitee.io/posts/5657d3d4.html","excerpt":"Event 对象Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。 事件通常与函数结合使用，函数不会在事件发生前被执行！ 本文用于记录个人学习过程中的两个小练习，其中包括一些事件对象的用法和问题的解决以及兼容性问题。 获取鼠标指针坐标 div跟随鼠标移动","text":"Event 对象Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。 事件通常与函数结合使用，函数不会在事件发生前被执行！ 本文用于记录个人学习过程中的两个小练习，其中包括一些事件对象的用法和问题的解决以及兼容性问题。 获取鼠标指针坐标 div跟随鼠标移动 练习1 获取鼠标指针坐标两个div，当鼠标在上面的div#areaDiv移动时，在下面的div#showMsg中显示鼠标指针坐标 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #areaDiv&#123; width: 500px; height: 200px; border: 1px solid black; &#125; #showMsg&#123; width: 500px; height: 50px; margin-top: 20px; border: 1px solid black; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; /* * 当鼠标在areaDiv中移动时，在showMsg中显示鼠标的坐标 */ //获取div var areaDiv = document.getElementById(&quot;areaDiv&quot;); var showMsg = document.getElementById(&quot;showMsg&quot;); /* * 事件对象 * - 当事件的响应函数被触发时，浏览器会将一个事件对象作为实参传递进响应函数， * 在事件对象中封装了当前事件相关的一切信息，比如：鼠标指针的坐标，键盘哪个按键被按下 */ areaDiv.onmousemove = function(event)&#123; /* * 在IE8中，响应函数被触发时，浏览器不会传递事件对象 * 而是将事件对象作为window对象的属性保存的 window.event * 但此方法不兼容火狐 */ /*解决兼容问题，使用if判断 if(!event)&#123; event = window.event; &#125;*/ //此方法更简单方便 event = event || window.event; /* 获取坐标值 * clientX 可以获取鼠标指针的水平坐标 * clientY 可以获取鼠标指针的垂直坐标 */ var x = event.clientX; var y = event.clientY; //显示坐标值 showMsg.innerHTML = &#x27;x=&#x27;+x+&#x27; , y=&#x27;+y; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;areaDiv&quot;&gt;&lt;/div&gt; &lt;div id=&quot;showMsg&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2 div跟随鼠标移动当鼠标在页面中移动时，使div跟随其移动 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;div跟随鼠标移动&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; width:2000px; height: 1000px;&#125; /*使页面出现滚动条*/ #box1&#123; width: 100px; height: 100px; background-color: red; position: absolute; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var box1 = document.getElementById(&quot;box1&quot;); //使div可以跟随鼠标移动，响应函数加给document document.onmousemove = function(event)&#123; event = event || window.event; //获取滚动条滚动距离 var st = document.documentElement.scrollTop; var sl = document.documentElement.scrollLeft; //获取鼠标指针坐标 /* clientX、clientY * 用于获取当前可见窗口的鼠标坐标 * 而div的偏移量是相对整个页面的 * * pageX、pageY可以获取鼠标相对当前页面的坐标 * 但是不兼容IE8及以下 * * 因此我们选择获取滚动条滚动距离，将其加到div的偏移量上 */ var left = event.clientX; var top = event.clientY; //设置div偏移量 box1.style.left = left +sl+&#x27;px&#x27;; box1.style.top = top +st+&#x27;px&#x27;; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 部分内容来源于网上教程，侵删。","categories":[{"name":"关于技术","slug":"关于技术","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"关于技术/JavaScript","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liyang1998.gitee.io/tags/JavaScript/"}]},{"title":"JavaScript数组的方法","slug":"JavaScript数组的方法","date":"2019-12-18T14:50:33.000Z","updated":"2021-04-27T15:16:49.000Z","comments":true,"path":"posts/f6df6a5d.html","link":"","permalink":"https://liyang1998.gitee.io/posts/f6df6a5d.html","excerpt":"数组数组的四个常用方法push() 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新长度 可以将要添加的元素作为方法的参数传递，这些元素将会自动添加到数组的末尾 pop() 该方法可以删除数组的最后一个元素，并将被删除的元素返回 unshift() 向数组开头添加一个或多个元素，并返回新的数组长度 添加元素后，其他元素的索引会相应调整 shift() 可以删除数组的第一个元素，并将其作为返回值返回","text":"数组数组的四个常用方法push() 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新长度 可以将要添加的元素作为方法的参数传递，这些元素将会自动添加到数组的末尾 pop() 该方法可以删除数组的最后一个元素，并将被删除的元素返回 unshift() 向数组开头添加一个或多个元素，并返回新的数组长度 添加元素后，其他元素的索引会相应调整 shift() 可以删除数组的第一个元素，并将其作为返回值返回 数组的遍历 for 循环 123456var arr = [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;马六&quot;];for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[i]);&#125; forEach * 1234567891011121314151617//forEach() 不支持IE9以下浏览器var arr = [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;马六&quot;];/* * forEach()方法需要一个函数作为参数 * - 像这种函数，由我们创建但不是我们调用的，我们称之为回调函数 * - 数组中有几个元素就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式 * 传递进来，我们可以定义形参，来读取这些内容 * - 浏览器会在回调函数中传递三个参数： * 第一个参数：当前正在遍历的元素 * 第二个参数：当前正在遍历的元素的索引 * 第三个参数：当前正在遍历的数组 */arr.forEach(function(value, index, obj)&#123; console.log(value);&#125;); slice()和splice()slice() 可以用来从数组中提取指定元素 参数：截取开始的位置索引，截取结束的位置索引 (前闭后开,第二个参数可以不写，默认取到最后一个元素) 索引可以是负值 -1为最后一个元素 splice() 删除元素并向数组添加新元素 将指定元素从原数组中删除并返回 参数：第一个：开始位置索引第二个：删除的数量第三个及以后：可以传递一些新的元素，这些元素会自动插入到开始索引位置之前 数组去重123456789101112131415161718192021//创建一个数组var arr = [1,2,3,2,1,3,4,2,5];//数组去重1 //获取数组中的每一个元素（遍历）for(var i=0; i&lt;arr.length; i++)&#123; //遍历当前元素后的所有元素 for(var j=i+1; j&lt;arr.length; j++)&#123; //判断两个元素值是否相等 if(arr[i]==arr[j])&#123; //相等则证明出现重复，删除j对应元素 arr.splice(j,1); //当删除了当前j所对应元素后，后面的元素会自动补位 //导致j新对应的元素无法进行比较，如果该元素依旧重复则会遗漏 //故使j自减 j--; &#125; &#125;&#125;console.log(arr); 数组其他方法123456789101112131415161718192021222324252627282930313233343536/* 1 * concat()可以连接两个或多个数组，并将新的数组返回 * - 该方法不会对原数组产生影响 * - 参数也可以为元素 *//* 2 * join()方法可以将数组转换为一个字符串 * - 该方法不会对原数组产生影响，而是将转换后的结果返回 * - 可以指定一个字符串作为参数，它将会作为数组元素的连接符，不填则默认为&quot;,&quot; *//* 3 * reverse()方法可以用来反转数组 * - 会直接操作原数组 *//* 4 * sort()用来对数组元素进行排序 * - 改变原数组 * - 默认按照Unicode编码进行排序，即使对纯数字数组排序一会按照Unicode编码排序 * - 我们可以自己指定排序规则，在sort()添加一个回调函数 * 回调函数中需要定义两个形参 * 浏览器将会分别使用数组中的元素作为实参去调用回调函数 * - 浏览器会根据回调函数的返回值来决定元素的顺序 * 如果返回一个大于0的值，则元素交换位置 * 如果返回一个小于0的值，则元素位置不变 * 如果返回一个0，则认为两个元素相等，不交换位置 */var arr = [5,4,1,3,2];arr.sort(function(a,b)&#123; return a - b; //升序 //return b - a; //降序&#125;);","categories":[{"name":"关于技术","slug":"关于技术","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"关于技术/JavaScript","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liyang1998.gitee.io/tags/JavaScript/"}]},{"title":"JavaScript构造函数","slug":"JavaScript构造函数学习笔记分享","date":"2019-12-18T07:06:47.000Z","updated":"2021-04-27T15:16:31.000Z","comments":true,"path":"posts/dd3a73b8.html","link":"","permalink":"https://liyang1998.gitee.io/posts/dd3a73b8.html","excerpt":"构造函数构造函数就是一个普通的函数，创建方式和普通函数没有区别 不同的是构造函数名习惯上首字母大写 普通函数是直接调用，而构造函数需要使用new关键字来调用 构造函数的执行流程： 立刻创建一个新的对象 将新建的对象设置为函数中的this（在构造函数中可以使用this来引用新建的对象） 逐行执行函数中的代码 将新建的对象作为返回值返回 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类 我们将通过一个函数创建的对象，称为是该类的实例","text":"构造函数构造函数就是一个普通的函数，创建方式和普通函数没有区别 不同的是构造函数名习惯上首字母大写 普通函数是直接调用，而构造函数需要使用new关键字来调用 构造函数的执行流程： 立刻创建一个新的对象 将新建的对象设置为函数中的this（在构造函数中可以使用this来引用新建的对象） 逐行执行函数中的代码 将新建的对象作为返回值返回 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类 我们将通过一个函数创建的对象，称为是该类的实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 创建一个Person构造函数 * - 在Person构造函数中，为每一个对象都添加了一个sayName方法 * 目前我们是在构造函数内部创建方法，这就导致了构造函数每执行一次就会创建一个方法 * 而且所有实例的sayName方法都是一模一样的但却是唯一的 * - 我们完全可以使所有对象共享一个方法 */function Person(name, age, gender)&#123; this.name = name; this.age = age; this.gender = gender; //1.在构造函数内部添加方法 /*this.sayName = function()&#123; alert(&quot;大家好，我是&quot;+this.name); &#125;;*/ //this.sayName = fun; //2.将sayName方法在全局作用域中定义，而不是在构造函数内部&#125;//将sayName方法在全局作用域中定义/* * 将函数定义在全局作用域，污染了全局作用域的命名空间 * 而且定义在全局作用域中也很不安全 * 解决：原型 *///function fun()&#123;// alert(&quot;大家好，我是&quot;+this.name);//&#125;//3.向原型中添加sayName方法Person.prototype.sayName = function()&#123; alert(&quot;大家好，我是&quot;+this.name);&#125;;//创建Person类的实例var person1 = new Person(&quot;李四&quot;, 18, &quot;男&quot;);var person2 = new Person(&quot;王五&quot;, 16, &quot;女&quot;);person1.sayName();person2.sayName();//使用instanceof可以检查一个对象是否是一个类的实例//console.log(person1 instanceof Person); //true/* * 所有对象都是Object的后代 * 所以任何对象和Object作instanceof检查时都会返回true *///console.log(person1 instanceof Object); //true 原型123456789101112131415161718192021222324252627282930313233343536373839/* * 原型prototype * 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype * 这个属性对应着一个对象，这个对象就是我们所谓的原型对象 * 如果函数作为普通函数调用prototype没有任何作用 * 当函数以创造函数的形式调用时，它所创建的对象中都会有一个隐含的属性 * 指向该构造函数的原型对象，我们可以通过__proto__来访问 * * 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到 * 我们可以将对象中共有的内容，统一设置到原型对象中 * * 当我们访问对象的属性或方法时，会现在对象自身中寻找，如果有则直接使用， * 没有则去原型中寻找... 直到找到Object的原型 * Object的原型没有原型(null)，如果在Object的原型中依然没有找到，则返回undefined * * 以后我们创建构造函数时，可以将这些对象共有的属性和方法，添加到构造函数的原型对象中 */function MyClass()&#123; &#125;//向MyClass的原型中添加属性aMyClass.prototype.a = 123;//向MyClass的原型中添加方法MyClass.prototype.sayHello = function()&#123; alert(&quot;Hello&quot;);&#125;;var mc = new MyClass();var mc2 = new MyClass();mc2.a = &quot;我是mc2中的a&quot;;//console.log(MyClass.prototype);//console.log(mc.__proto__ == MyClass.prototype); //trueconsole.log(mc.a); //123console.log(mc2.a); //我是mc2中的a 1234567891011121314151617function MyClass()&#123; &#125;//向MyClass的原型中添加属性nameMyClass.prototype.name = &quot;我是原型中的名字&quot;;var mc = new MyClass();mc.age = 18;//使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true//console.log(&quot;name&quot; in mc); //true//可以使用hasOwnProperty()来检查对象自身中是否有该属性//使用该方法只有当对象自身含有该属性时，才会返回trueconsole.log(mc.hasOwnProperty(&quot;name&quot;)); //falseconsole.log(mc.hasOwnProperty(&quot;age&quot;)); //true 原文地址：博客园 https://www.cnblogs.com/meow999/p/12059917.html","categories":[{"name":"关于技术","slug":"关于技术","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"关于技术/JavaScript","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liyang1998.gitee.io/tags/JavaScript/"}]},{"title":"JavaScript 实现图片滚动","slug":"JavaScript-pic_move","date":"2019-12-10T13:13:14.000Z","updated":"2021-04-29T16:34:32.000Z","comments":true,"path":"posts/6d2ec284.html","link":"","permalink":"https://liyang1998.gitee.io/posts/6d2ec284.html","excerpt":"定时器应用：图片滚动分享一下最近学习的JavaScript定时器实现图片的无缝滚动。 间隔型定时器setInterval()与clearInterval() 12var timer = setInterval(func, delay); //第一个参数为定时器要执行的函数，第二个参数为定时器间隔，单位msclearInterval(timer); //停止定时器，参数为setInterval()所启动的定时器 原理和方法 让ul一直向左移动 –&gt; 减少left值 –&gt; offsetLeft 1oUl.style.left&#x3D;oUl.offsetLeft-1+&#39;px&#39;; 复制li 我们演示的是div宽度可以容纳4张图片，而一共有4张图，所以我们要把4张图复制一份并接到后面 innerHTML 1oUl.innerHTML+=oUl.innerHTML; 修改ul的width 原先的ul宽度足以容纳内容，所以需要重新调整否则图片将分两行显示 1oUl.style.width=aLi[0].offsetWidth*aLi.length+&#x27;px&#x27;; 过界重设位置 当ul走完半程即第一份的4张图全部走出容器时，重设ul位置，回到起点，即可实现无缝滚动 判断: 1234if(oUl.offsetLeft&lt;-oUl.offsetWidth/2)&#123; oUl.style.left=&#x27;0&#x27;;&#125;","text":"定时器应用：图片滚动分享一下最近学习的JavaScript定时器实现图片的无缝滚动。 间隔型定时器setInterval()与clearInterval() 12var timer = setInterval(func, delay); //第一个参数为定时器要执行的函数，第二个参数为定时器间隔，单位msclearInterval(timer); //停止定时器，参数为setInterval()所启动的定时器 原理和方法 让ul一直向左移动 –&gt; 减少left值 –&gt; offsetLeft 1oUl.style.left&#x3D;oUl.offsetLeft-1+&#39;px&#39;; 复制li 我们演示的是div宽度可以容纳4张图片，而一共有4张图，所以我们要把4张图复制一份并接到后面 innerHTML 1oUl.innerHTML+=oUl.innerHTML; 修改ul的width 原先的ul宽度足以容纳内容，所以需要重新调整否则图片将分两行显示 1oUl.style.width=aLi[0].offsetWidth*aLi.length+&#x27;px&#x27;; 过界重设位置 当ul走完半程即第一份的4张图全部走出容器时，重设ul位置，回到起点，即可实现无缝滚动 判断: 1234if(oUl.offsetLeft&lt;-oUl.offsetWidth/2)&#123; oUl.style.left=&#x27;0&#x27;;&#125; 图片演示 此图为初始结构示意 外层为div容器，内部为ul图片列表，4张图片，则设置div宽度等于图片宽度*4 如图，当ul向左移动后右侧没有内容进行显示，故我们进行复制li操作 （外层容器div设置overflow:hidden;属性，已经走出div范围的部分不会显示） 复制li后再进行移动则会产生如图所示效果（两侧超出内容隐藏） 当ul走完一半宽度（如图），此时显示内容原始内容相同，故我们重设ul位置，在视觉上实现无缝滚动 重设ul位置，回到初始状态 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;图片滚动&lt;/title&gt; &lt;style&gt; #div1&#123; position: relative; width: 1200px; height: 437px; margin: 100px auto; overflow: hidden; border-radius: 15px; &#125; .pic-list&#123; position: absolute; left: 0; top: 0; &#125; .pic-list li&#123; float: left; width: 300px; height: 437px; list-style: none; &#125; .pic-list img&#123; width: 300px; height: 437px; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; var oDiv=document.getElementById(&#x27;div1&#x27;); var oUl=oDiv.getElementsByClassName(&#x27;pic-list&#x27;); var aLi=oUl.getElementsByTagName(&#x27;li&#x27;); oUl.innerHTML+=oUl.innerHTML; //将图片列表复制一份接到后面，长度必须大于等于div一次可显示长度 oUl.style.width=aLi[0].offsetWidth*aLi.length+&#x27;px&#x27;; //重新设置ul宽度=一个li宽度*li个数 //图片滚动函数 function move()&#123; //if条件判断作用： //当ul走完一半的时候重新回到原点，即可实现无缝滚动 if(oUl.offsetLeft&lt;-oUl.offsetWidth/2)&#123; oUl.style.left=&#x27;0&#x27;; &#125; oUl.style.left=oUl.offsetLeft-1+&#x27;px&#x27;; //每单位时间往左移动1px &#125; var timer = setInterval(move,30); //设置定时器，间隔30ms oDiv.onmouseover=function()&#123; //鼠标移入停止滚动 clearInterval(timer); &#125;; oDiv.onmouseout=function()&#123; //鼠标移出开始滚动 timer=setInterval(move,30); &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;ul class=&quot;pic-list&quot;&gt; &lt;li&gt;&lt;img src=&quot;img/1.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;img/2.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;img/3.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;img/4.jpg&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 小结这是之前学习的利用原生JS定时器制作图片滚动效果，比较基础，做一下记录总结 初学前端，小白一枚，有问题还望指正 欢迎志同道合的小伙伴与我交流o(￣▽￣)ブ","categories":[{"name":"关于技术","slug":"关于技术","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"关于技术/JavaScript","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liyang1998.gitee.io/tags/JavaScript/"},{"name":"图片滚动","slug":"图片滚动","permalink":"https://liyang1998.gitee.io/tags/%E5%9B%BE%E7%89%87%E6%BB%9A%E5%8A%A8/"}]},{"title":"Hexo+Github个人博客搭建详细教程","slug":"Hexo-Github_blog","date":"2019-12-05T08:54:34.000Z","updated":"2021-04-23T03:05:29.000Z","comments":true,"path":"posts/acf3d1d8.html","link":"","permalink":"https://liyang1998.gitee.io/posts/acf3d1d8.html","excerpt":"概述使用Hexo搭建个人博客并利用GitHub进行部署。 很久之前就想搭建一个博客，可是也一直没有行动，最近在逛B站的时候发现一个up主（CodeSheep）的一个视频 《手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo》: https://www.bilibili.com/video/av44544186/ ，哈哈哈哈哈给他免费打个广告（虽然根本没人能看到），简直就是保姆级的教学视频，良心up主啊，真·手把手教学，大体浏览了一下以后我就坐不住了，马上起来开电脑行动！ 那在这里就简单总结一下过程和遇到的坑吧","text":"概述使用Hexo搭建个人博客并利用GitHub进行部署。 很久之前就想搭建一个博客，可是也一直没有行动，最近在逛B站的时候发现一个up主（CodeSheep）的一个视频 《手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo》: https://www.bilibili.com/video/av44544186/ ，哈哈哈哈哈给他免费打个广告（虽然根本没人能看到），简直就是保姆级的教学视频，良心up主啊，真·手把手教学，大体浏览了一下以后我就坐不住了，马上起来开电脑行动！ 那在这里就简单总结一下过程和遇到的坑吧 搭建博客博客是基于Hexo搭建的，需要Node.js、Git等支持 我用的是windows系统，而up主是在MacOS系统下操作的，其实大同小异。 安装Node.js 搜索引擎搜索Node.js或者直接访问 https://nodejs.org 下载左边那个LTS版本 下载完成后安装，使用 Node.js 官方安装程序时，请确保勾选 Add to PATH 选项（默认已勾选） 在cmd下分别输入命令行node -v和npm -v检查是否安装成功 安装Git 搜索引擎搜索git或者直接访问 https://git-scm.com/downloads 选择对应的操作系统下载 安装（在桌面或任意文件夹下右键菜单如果出现‘Git Bash Here’则说明成功） 安装cnpm（可选）由于国内镜像源速度较慢，所以先利用npm下载cnpm 在cmd中执行以下命令： npm install -g cnpm --registry=https://registry.npm.taobao.org 安装Hexo用以下命令安装hexo（没有安装cnpm则换成npm即可）： cnpm install -g hexo-cli 完成后运行hexo -v 查看版本以检查是否安装成功 开始搭建博客创建一个文件夹，例如：D:\\blog 转到此路径，然后运行hexo init进行初始化，也可以直接用hexo init D:\\blog 看到INFO Start blogging with Hexo!则说明成功 此时你会发现对应目录下已经为你自动生成了一些文件 12345678910111213C:\\WINDOWS\\system32&gt;d:D:\\&gt;cd blogD:\\blog&gt;D:\\blog&gt;hexo init或者直接C:\\WINDOWS\\system32&gt;hexo init D:\\blog...INFO Start blogging with Hexo!D:\\blog&gt; 启动只需要hexo server或者直接简写hexo s即可启动 123D:\\blog&gt;hexo sINFO Start processingINFO Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop. 看到以上提示说明启动成功，然后打开浏览器访问 http://localhost:4000 即可看到博客页面 新建文章用hexo new &quot;My New Post&quot;新建博客文章 12D:\\blog&gt;hexo new &quot;我的第一篇博客文章&quot;INFO Created: D:\\blog\\source\\_posts\\我的第一篇博客文章.md 可以看到生成的文件是.md后缀即markdown格式，你需要了解一下markdown 生成静态文件hexo generate或者hexo g 生成静态文件。 hexo s 重新启动服务器即可看到新添加的文章了。 部署博客这里我们用利用Github将博客进行免费部署。 创建Github库首先你需要有一个Github账号，然后新建一个库，库的名字为：username.github.io 注意此处username必须为你的用户名！ 安装部署插件 cnpm install --save hexo-deployer-git 更改配置文件在你的目录找到名为_config.yml的文件，用文本编辑器打开文件，找到最下面的‘deploy’项，将内容改为如下： 1234deploy: type: git repo: https://github.com/username/username.githu.io.git # 或者SSH branch: master 进行部署命令很简单只需要一行 hexo d 即可，过程会提示你输入你的 Github 的账号密码，正确输入即可。 成功提示 INFO Deployer done: git 然后刷新你的仓库你会发现多了很多东西 访问博客地址部署完成后访问username.github.io 如果出问题的话将 Git 与 Github 的用户名改为一致后重试 1234567891011查看用户名和邮箱地址：git config user.namegit config user.email修改用户名和邮箱地址:git config --global user.name &quot;xxxx&quot;git config --global user.email &quot;xxxx&quot; 更换主题请看这篇文章：焕然一新的博客","categories":[{"name":"关于博客","slug":"关于博客","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://liyang1998.gitee.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://liyang1998.gitee.io/tags/Hexo/"}]}],"categories":[{"name":"关于技术","slug":"关于技术","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/"},{"name":"JavaScript","slug":"关于技术/JavaScript","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/"},{"name":"游戏","slug":"关于技术/JavaScript/游戏","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/%E6%B8%B8%E6%88%8F/"},{"name":"ES6","slug":"关于技术/JavaScript/ES6","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/JavaScript/ES6/"},{"name":"关于博客","slug":"关于博客","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"},{"name":"Vue","slug":"关于技术/Vue","permalink":"https://liyang1998.gitee.io/categories/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF/Vue/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://liyang1998.gitee.io/tags/JavaScript/"},{"name":"JS游戏","slug":"JS游戏","permalink":"https://liyang1998.gitee.io/tags/JS%E6%B8%B8%E6%88%8F/"},{"name":"H5游戏","slug":"H5游戏","permalink":"https://liyang1998.gitee.io/tags/H5%E6%B8%B8%E6%88%8F/"},{"name":"面向对象","slug":"面向对象","permalink":"https://liyang1998.gitee.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"贪吃蛇","slug":"贪吃蛇","permalink":"https://liyang1998.gitee.io/tags/%E8%B4%AA%E5%90%83%E8%9B%87/"},{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"https://liyang1998.gitee.io/tags/JavaScirpt/"},{"name":"ES6","slug":"ES6","permalink":"https://liyang1998.gitee.io/tags/ES6/"},{"name":"解构","slug":"解构","permalink":"https://liyang1998.gitee.io/tags/%E8%A7%A3%E6%9E%84/"},{"name":"扩展运算符","slug":"扩展运算符","permalink":"https://liyang1998.gitee.io/tags/%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"name":"笔记","slug":"笔记","permalink":"https://liyang1998.gitee.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"知识总结","slug":"知识总结","permalink":"https://liyang1998.gitee.io/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"name":"博客","slug":"博客","permalink":"https://liyang1998.gitee.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://liyang1998.gitee.io/tags/Hexo/"},{"name":"永久链接","slug":"永久链接","permalink":"https://liyang1998.gitee.io/tags/%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5/"},{"name":"permalink","slug":"permalink","permalink":"https://liyang1998.gitee.io/tags/permalink/"},{"name":"Vue","slug":"Vue","permalink":"https://liyang1998.gitee.io/tags/Vue/"},{"name":"自定义指令","slug":"自定义指令","permalink":"https://liyang1998.gitee.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"},{"name":"el-select","slug":"el-select","permalink":"https://liyang1998.gitee.io/tags/el-select/"},{"name":"懒加载","slug":"懒加载","permalink":"https://liyang1998.gitee.io/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"},{"name":"Butterfly","slug":"Butterfly","permalink":"https://liyang1998.gitee.io/tags/Butterfly/"},{"name":"图片滚动","slug":"图片滚动","permalink":"https://liyang1998.gitee.io/tags/%E5%9B%BE%E7%89%87%E6%BB%9A%E5%8A%A8/"}]}