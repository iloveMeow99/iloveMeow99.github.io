{"meta":{"title":"Yangyang's Blog","subtitle":"","description":"一个前端","author":"Yangyang","url":"http://liyang1998.gitee.io","root":"/"},"pages":[{"title":"Ordinary but unique","date":"2020-02-27T08:30:12.000Z","updated":"2021-04-02T01:54:56.141Z","comments":false,"path":"about/index.html","permalink":"http://liyang1998.gitee.io/about/index.html","excerpt":"","text":".title p{ font-size: 20px;} .content{ padding-left: 15px; font-size: 16px;} 关于我 Yangyang 一位自学者 喜欢音乐，热爱编程 我很菜，我们一起学习进步 关于博客 本博客是基于Hexo搭建的，主题为Butterfly 主要用来记录学习，分享知识"},{"title":"分类","date":"2020-02-26T12:45:57.000Z","updated":"2021-04-02T01:54:56.142Z","comments":false,"path":"categories/index.html","permalink":"http://liyang1998.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-02-26T12:46:50.000Z","updated":"2021-04-02T01:54:56.142Z","comments":true,"path":"link/index.html","permalink":"http://liyang1998.gitee.io/link/index.html","excerpt":"","text":""},{"title":"留下足迹","date":"2020-02-26T12:49:17.000Z","updated":"2021-04-02T01:54:56.143Z","comments":true,"path":"messageboard/index.html","permalink":"http://liyang1998.gitee.io/messageboard/index.html","excerpt":"","text":"有什么想说的 有什么想问的 有什么想吐槽的 在下面留言告诉我吧"},{"title":"热爱生活，热爱音乐","date":"2020-02-26T12:54:38.000Z","updated":"2021-04-06T03:41:55.002Z","comments":true,"path":"music/index.html","permalink":"http://liyang1998.gitee.io/music/index.html","excerpt":"","text":"IU var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":0,\"mode\":\"random\",\"mutex\":true,\"theme\":\"#e6d0b2\",\"preload\":\"metadata\",\"listmaxheight\":\"513px\",\"music\":[{\"title\":\"삐삐 - (BBIBBI)\",\"author\":\"IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=1316563427\",\"pic\":\"https://pic.xiami.net/images/album/img14/196/5bbdc4a4491bc_9841114_1539163300.jpg?x-oss-process=image/quality,q_80/format,jpg\"},{\"title\":\"Blueming\",\"author\":\"IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=1404511131\",\"pic\":\"https://pic.xiami.net/images/album/img67/13/5dd25f4b8247f_679267_1574068043.jpg?x-oss-process=image/quality,q_80/format,jpg\"},{\"title\":\"Love poem\",\"author\":\"IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=1400436688\",\"pic\":\"https://pic.xiami.net/images/album/img9/60/5dbbf5e4db403_3020209_1572599268.jpg?x-oss-process=image/quality,q_80/format,jpg\"},{\"title\":\"囍帖街 (Live)\",\"author\":\"IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=35847131\",\"pic\":\"https://pic.xiami.net/images/album/img22/56822/21003906211474253302.jpeg?x-oss-process=image/quality,q_80/format,jpg\"},{\"title\":\"봄 사랑 벚꽃 말고 (除了春天 爱情和樱花)\",\"author\":\"High4 / IU\",\"url\":\"http://music.163.com/song/media/outer/url?id=28391219\",\"pic\":\"https://pic.xiami.net/images/album/img82/1895391682/2970987581402380352.jpg?x-oss-process=image/quality,q_80/format,jpg\"}]}; options.element = document.getElementById(\"aplayer-dKqNydLR\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);"},{"title":"标签","date":"2020-02-26T12:44:18.000Z","updated":"2021-04-02T01:54:56.144Z","comments":false,"path":"tags/index.html","permalink":"http://liyang1998.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"焕然一新的博客","slug":"焕然一新的博客","date":"2020-03-01T08:02:57.000Z","updated":"2021-04-02T10:18:26.142Z","comments":true,"path":"20200301/焕然一新的博客/","link":"","permalink":"http://liyang1998.gitee.io/20200301/%E7%84%95%E7%84%B6%E4%B8%80%E6%96%B0%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"发现了一款甚合我意的主题 Butterfly 快速上手主题主题下载在你 hexo 根目录下执行这行代码： git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly 更改设置安装完后修改根目录的配置文件_config.yml: 1theme: Butterfly 如果你没有 pug 和 stylus 渲染器，你还需要执行： ​ npm install hexo-renderer-pug hexo-renderer-stylus 安装依赖​ 如果你是 Hexo 4.2.0 及以上版本会报错 ​ Error: Cannot find module &#39;cheerio&#39; ​ 所以需要先安装cheerio ​ npm install cheerio@0.22.0 --save 主题平滑升级为了主题的平滑升级,Butterfly 使用了 data files特性。 推荐把主题默认的配置文件_config.yml复制到 Hexo 工作目录下的source/_data/butterfly.yml，如果source/_data的目录不存在那就创建一个。 注意，如果你创建了butterfly.yml, 它将会替换主题默认配置文件_config.yml里的配置项 (不是合并而是替换), 之后你就只需要通过git pull的方式就可以平滑地升级 theme-butterfly了。 从3.3.0开始，以上方法不再支持 请改用以下方法，此方法只支持 Hexo 5.0.0 以上版本 如果已經在 source/_data/ 創建了 butterfly.yml，請記得刪除掉。 把主題文件夾中的 _config.yml 複製到 Hexo 根目錄裏，同時重新命名為 _config.butterfly.yml。 以後只需要在 _config.butterfly.yml 進行配置就行。 Hexo會自動合併主題中的 _config.yml 和 _config.butterfly.yml 裏的配置，如果存在同名配置，會使用 _config.butterfly.yml 的配置，其優先度較高。 更多配置请查看Hexo和主题官方文档Butterfly 安裝文檔(一) 快速開始","categories":[{"name":"教程","slug":"教程","permalink":"http://liyang1998.gitee.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"http://liyang1998.gitee.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"JS事件绑定自定义(兼容IE8方法)","slug":"JavaScript事件绑定问题","date":"2019-12-29T10:47:14.000Z","updated":"2021-04-02T01:54:56.141Z","comments":true,"path":"20191229/JavaScript事件绑定问题/","link":"","permalink":"http://liyang1998.gitee.io/20191229/JavaScript%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E9%97%AE%E9%A2%98/","excerpt":"JavaScript事件绑定常用方法 对象.事件 = 函数; 它只能同时为一个对象的一个事件绑定一个响应函数不能绑定多个，如果有多个，后面的会覆盖前面的 addEventListener() 此方法也可以为元素绑定响应函数 参数： 事件的字符串(不带on) 回调函数，事件触发时执行 是否在捕获阶段触发事件，一般都传false 使用此方法可以为一个元素的同一事件绑定多个响应函数 当事件触发时，按绑定顺序依次执行 attachEvent() IE8及以下浏览器不支持addEventListener()方法，但可以使用attachEvent()方法起到同样的效果 参数: 事件字符串(带on) 回调函数 此方法也可以绑定多个函数，不过函数执行顺序与addEventListener()相反 this问题与解决 addEventListener()中的this是绑定事件的对象attachEvent()中的this是window如果要解决兼容性问题则需要统一两个方法的this 这里我们用到了call()方法call()可以用来改变函数的this","text":"JavaScript事件绑定常用方法 对象.事件 = 函数; 它只能同时为一个对象的一个事件绑定一个响应函数不能绑定多个，如果有多个，后面的会覆盖前面的 addEventListener() 此方法也可以为元素绑定响应函数 参数： 事件的字符串(不带on) 回调函数，事件触发时执行 是否在捕获阶段触发事件，一般都传false 使用此方法可以为一个元素的同一事件绑定多个响应函数 当事件触发时，按绑定顺序依次执行 attachEvent() IE8及以下浏览器不支持addEventListener()方法，但可以使用attachEvent()方法起到同样的效果 参数: 事件字符串(带on) 回调函数 此方法也可以绑定多个函数，不过函数执行顺序与addEventListener()相反 this问题与解决 addEventListener()中的this是绑定事件的对象attachEvent()中的this是window如果要解决兼容性问题则需要统一两个方法的this 这里我们用到了call()方法call()可以用来改变函数的this 函数bind()自己定义一个函数用来给一个对象绑定事件 思路 三个参数：对象，事件，回调函数 兼容性： 通过if判断对象是否存在addEventListener方法来区分浏览器 this问题的解决 由于传入的回调函数是浏览器调用的，我们无法去操作，所以我们在attachEvent()不直接传入回调函数，而是先定义一个匿名函数，然后在函数内部调用回调函数，并利用call方法改变this 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var btn1 = document.getElementById(&quot;btn1&quot;); bind(btn1, &quot;click&quot;,function()&#123; alert(this); &#125;); &#125;; //定义一个函数bind()，用来为指定元素绑定事件响应函数 /* * 参数： * obj 要绑定事件的对象 * eventStr 事件的字符串 * func 回调函数 */ function bind(obj, eventStr, func)&#123; //判断是否有addEventListener()方法 if(obj.addEventListener)&#123; //大部分浏览器兼容的方式 obj.addEventListener(eventStr, func, false); &#125; else&#123; //IE8及以下 注意 on //obj.attachEvent(&quot;on&quot;+eventStr, func);//此方法this为window下面提供解决方法 //统一this 不直接调用func而是在匿名函数内调用 obj.attachEvent(&quot;on&quot;+eventStr, function()&#123; //在匿名函数内调用回调函数 利用call()方法将this改为obj func.call(obj); &#125;); &#125; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;btn1&quot;&gt;btn1&lt;/button&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://liyang1998.gitee.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://liyang1998.gitee.io/tags/JavaScript/"}]},{"title":"JavaScript DOM事件对象练习","slug":"JavaScriptDOM事件对象练习-学习内容分享","date":"2019-12-27T07:29:44.000Z","updated":"2021-04-02T01:54:56.140Z","comments":true,"path":"20191227/JavaScriptDOM事件对象练习-学习内容分享/","link":"","permalink":"http://liyang1998.gitee.io/20191227/JavaScriptDOM%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%BB%83%E4%B9%A0-%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/","excerpt":"Event 对象Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。 事件通常与函数结合使用，函数不会在事件发生前被执行！ 本文用于记录个人学习过程中的两个小练习，其中包括一些事件对象的用法和问题的解决以及兼容性问题。 获取鼠标指针坐标 div跟随鼠标移动","text":"Event 对象Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。 事件通常与函数结合使用，函数不会在事件发生前被执行！ 本文用于记录个人学习过程中的两个小练习，其中包括一些事件对象的用法和问题的解决以及兼容性问题。 获取鼠标指针坐标 div跟随鼠标移动 练习1 获取鼠标指针坐标两个div，当鼠标在上面的div#areaDiv移动时，在下面的div#showMsg中显示鼠标指针坐标 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #areaDiv&#123; width: 500px; height: 200px; border: 1px solid black; &#125; #showMsg&#123; width: 500px; height: 50px; margin-top: 20px; border: 1px solid black; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; /* * 当鼠标在areaDiv中移动时，在showMsg中显示鼠标的坐标 */ //获取div var areaDiv = document.getElementById(&quot;areaDiv&quot;); var showMsg = document.getElementById(&quot;showMsg&quot;); /* * 事件对象 * - 当事件的响应函数被触发时，浏览器会将一个事件对象作为实参传递进响应函数， * 在事件对象中封装了当前事件相关的一切信息，比如：鼠标指针的坐标，键盘哪个按键被按下 */ areaDiv.onmousemove = function(event)&#123; /* * 在IE8中，响应函数被触发时，浏览器不会传递事件对象 * 而是将事件对象作为window对象的属性保存的 window.event * 但此方法不兼容火狐 */ /*解决兼容问题，使用if判断 if(!event)&#123; event = window.event; &#125;*/ //此方法更简单方便 event = event || window.event; /* 获取坐标值 * clientX 可以获取鼠标指针的水平坐标 * clientY 可以获取鼠标指针的垂直坐标 */ var x = event.clientX; var y = event.clientY; //显示坐标值 showMsg.innerHTML = &#x27;x=&#x27;+x+&#x27; , y=&#x27;+y; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;areaDiv&quot;&gt;&lt;/div&gt; &lt;div id=&quot;showMsg&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2 div跟随鼠标移动当鼠标在页面中移动时，使div跟随其移动 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;div跟随鼠标移动&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; width:2000px; height: 1000px;&#125; /*使页面出现滚动条*/ #box1&#123; width: 100px; height: 100px; background-color: red; position: absolute; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var box1 = document.getElementById(&quot;box1&quot;); //使div可以跟随鼠标移动，响应函数加给document document.onmousemove = function(event)&#123; event = event || window.event; //获取滚动条滚动距离 var st = document.documentElement.scrollTop; var sl = document.documentElement.scrollLeft; //获取鼠标指针坐标 /* clientX、clientY * 用于获取当前可见窗口的鼠标坐标 * 而div的偏移量是相对整个页面的 * * pageX、pageY可以获取鼠标相对当前页面的坐标 * 但是不兼容IE8及以下 * * 因此我们选择获取滚动条滚动距离，将其加到div的偏移量上 */ var left = event.clientX; var top = event.clientY; //设置div偏移量 box1.style.left = left +sl+&#x27;px&#x27;; box1.style.top = top +st+&#x27;px&#x27;; &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 部分内容来源于网上教程，侵删。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://liyang1998.gitee.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://liyang1998.gitee.io/tags/JavaScript/"}]},{"title":"JavaScript数组的方法","slug":"JavaScript数组的方法","date":"2019-12-18T14:50:33.000Z","updated":"2021-04-02T01:54:56.141Z","comments":true,"path":"20191218/JavaScript数组的方法/","link":"","permalink":"http://liyang1998.gitee.io/20191218/JavaScript%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"数组数组的四个常用方法push() 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新长度 可以将要添加的元素作为方法的参数传递，这些元素将会自动添加到数组的末尾 pop() 该方法可以删除数组的最后一个元素，并将被删除的元素返回 unshift() 向数组开头添加一个或多个元素，并返回新的数组长度 添加元素后，其他元素的索引会相应调整 shift() 可以删除数组的第一个元素，并将其作为返回值返回","text":"数组数组的四个常用方法push() 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新长度 可以将要添加的元素作为方法的参数传递，这些元素将会自动添加到数组的末尾 pop() 该方法可以删除数组的最后一个元素，并将被删除的元素返回 unshift() 向数组开头添加一个或多个元素，并返回新的数组长度 添加元素后，其他元素的索引会相应调整 shift() 可以删除数组的第一个元素，并将其作为返回值返回 数组的遍历 for 循环 123456var arr = [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;马六&quot;];for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[i]);&#125; forEach * 1234567891011121314151617//forEach() 不支持IE9以下浏览器var arr = [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;马六&quot;];/* * forEach()方法需要一个函数作为参数 * - 像这种函数，由我们创建但不是我们调用的，我们称之为回调函数 * - 数组中有几个元素就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式 * 传递进来，我们可以定义形参，来读取这些内容 * - 浏览器会在回调函数中传递三个参数： * 第一个参数：当前正在遍历的元素 * 第二个参数：当前正在遍历的元素的索引 * 第三个参数：当前正在遍历的数组 */arr.forEach(function(value, index, obj)&#123; console.log(value);&#125;); slice()和splice()slice() 可以用来从数组中提取指定元素 参数：截取开始的位置索引，截取结束的位置索引 (前闭后开,第二个参数可以不写，默认取到最后一个元素) 索引可以是负值 -1为最后一个元素 splice() 删除元素并向数组添加新元素 将指定元素从原数组中删除并返回 参数：第一个：开始位置索引第二个：删除的数量第三个及以后：可以传递一些新的元素，这些元素会自动插入到开始索引位置之前 数组去重123456789101112131415161718192021//创建一个数组var arr = [1,2,3,2,1,3,4,2,5];//数组去重1 //获取数组中的每一个元素（遍历）for(var i=0; i&lt;arr.length; i++)&#123; //遍历当前元素后的所有元素 for(var j=i+1; j&lt;arr.length; j++)&#123; //判断两个元素值是否相等 if(arr[i]==arr[j])&#123; //相等则证明出现重复，删除j对应元素 arr.splice(j,1); //当删除了当前j所对应元素后，后面的元素会自动补位 //导致j新对应的元素无法进行比较，如果该元素依旧重复则会遗漏 //故使j自减 j--; &#125; &#125;&#125;console.log(arr); 数组其他方法123456789101112131415161718192021222324252627282930313233343536/* 1 * concat()可以连接两个或多个数组，并将新的数组返回 * - 该方法不会对原数组产生影响 * - 参数也可以为元素 *//* 2 * join()方法可以将数组转换为一个字符串 * - 该方法不会对原数组产生影响，而是将转换后的结果返回 * - 可以指定一个字符串作为参数，它将会作为数组元素的连接符，不填则默认为&quot;,&quot; *//* 3 * reverse()方法可以用来反转数组 * - 会直接操作原数组 *//* 4 * sort()用来对数组元素进行排序 * - 改变原数组 * - 默认按照Unicode编码进行排序，即使对纯数字数组排序一会按照Unicode编码排序 * - 我们可以自己指定排序规则，在sort()添加一个回调函数 * 回调函数中需要定义两个形参 * 浏览器将会分别使用数组中的元素作为实参去调用回调函数 * - 浏览器会根据回调函数的返回值来决定元素的顺序 * 如果返回一个大于0的值，则元素交换位置 * 如果返回一个小于0的值，则元素位置不变 * 如果返回一个0，则认为两个元素相等，不交换位置 */var arr = [5,4,1,3,2];arr.sort(function(a,b)&#123; return a - b; //升序 //return b - a; //降序&#125;);","categories":[{"name":"笔记","slug":"笔记","permalink":"http://liyang1998.gitee.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://liyang1998.gitee.io/tags/JavaScript/"}]},{"title":"JavaScript构造函数","slug":"JavaScript构造函数学习笔记分享","date":"2019-12-18T07:06:47.000Z","updated":"2021-04-02T01:54:56.141Z","comments":true,"path":"20191218/JavaScript构造函数学习笔记分享/","link":"","permalink":"http://liyang1998.gitee.io/20191218/JavaScript%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%88%86%E4%BA%AB/","excerpt":"构造函数构造函数就是一个普通的函数，创建方式和普通函数没有区别 不同的是构造函数名习惯上首字母大写 普通函数是直接调用，而构造函数需要使用new关键字来调用 构造函数的执行流程： 立刻创建一个新的对象 将新建的对象设置为函数中的this（在构造函数中可以使用this来引用新建的对象） 逐行执行函数中的代码 将新建的对象作为返回值返回 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类 我们将通过一个函数创建的对象，称为是该类的实例","text":"构造函数构造函数就是一个普通的函数，创建方式和普通函数没有区别 不同的是构造函数名习惯上首字母大写 普通函数是直接调用，而构造函数需要使用new关键字来调用 构造函数的执行流程： 立刻创建一个新的对象 将新建的对象设置为函数中的this（在构造函数中可以使用this来引用新建的对象） 逐行执行函数中的代码 将新建的对象作为返回值返回 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类 我们将通过一个函数创建的对象，称为是该类的实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 创建一个Person构造函数 * - 在Person构造函数中，为每一个对象都添加了一个sayName方法 * 目前我们是在构造函数内部创建方法，这就导致了构造函数每执行一次就会创建一个方法 * 而且所有实例的sayName方法都是一模一样的但却是唯一的 * - 我们完全可以使所有对象共享一个方法 */function Person(name, age, gender)&#123; this.name = name; this.age = age; this.gender = gender; //1.在构造函数内部添加方法 /*this.sayName = function()&#123; alert(&quot;大家好，我是&quot;+this.name); &#125;;*/ //this.sayName = fun; //2.将sayName方法在全局作用域中定义，而不是在构造函数内部&#125;//将sayName方法在全局作用域中定义/* * 将函数定义在全局作用域，污染了全局作用域的命名空间 * 而且定义在全局作用域中也很不安全 * 解决：原型 *///function fun()&#123;// alert(&quot;大家好，我是&quot;+this.name);//&#125;//3.向原型中添加sayName方法Person.prototype.sayName = function()&#123; alert(&quot;大家好，我是&quot;+this.name);&#125;;//创建Person类的实例var person1 = new Person(&quot;李四&quot;, 18, &quot;男&quot;);var person2 = new Person(&quot;王五&quot;, 16, &quot;女&quot;);person1.sayName();person2.sayName();//使用instanceof可以检查一个对象是否是一个类的实例//console.log(person1 instanceof Person); //true/* * 所有对象都是Object的后代 * 所以任何对象和Object作instanceof检查时都会返回true *///console.log(person1 instanceof Object); //true 原型123456789101112131415161718192021222324252627282930313233343536373839/* * 原型prototype * 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype * 这个属性对应着一个对象，这个对象就是我们所谓的原型对象 * 如果函数作为普通函数调用prototype没有任何作用 * 当函数以创造函数的形式调用时，它所创建的对象中都会有一个隐含的属性 * 指向该构造函数的原型对象，我们可以通过__proto__来访问 * * 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到 * 我们可以将对象中共有的内容，统一设置到原型对象中 * * 当我们访问对象的属性或方法时，会现在对象自身中寻找，如果有则直接使用， * 没有则去原型中寻找... 直到找到Object的原型 * Object的原型没有原型(null)，如果在Object的原型中依然没有找到，则返回undefined * * 以后我们创建构造函数时，可以将这些对象共有的属性和方法，添加到构造函数的原型对象中 */function MyClass()&#123; &#125;//向MyClass的原型中添加属性aMyClass.prototype.a = 123;//向MyClass的原型中添加方法MyClass.prototype.sayHello = function()&#123; alert(&quot;Hello&quot;);&#125;;var mc = new MyClass();var mc2 = new MyClass();mc2.a = &quot;我是mc2中的a&quot;;//console.log(MyClass.prototype);//console.log(mc.__proto__ == MyClass.prototype); //trueconsole.log(mc.a); //123console.log(mc2.a); //我是mc2中的a 1234567891011121314151617function MyClass()&#123; &#125;//向MyClass的原型中添加属性nameMyClass.prototype.name = &quot;我是原型中的名字&quot;;var mc = new MyClass();mc.age = 18;//使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true//console.log(&quot;name&quot; in mc); //true//可以使用hasOwnProperty()来检查对象自身中是否有该属性//使用该方法只有当对象自身含有该属性时，才会返回trueconsole.log(mc.hasOwnProperty(&quot;name&quot;)); //falseconsole.log(mc.hasOwnProperty(&quot;age&quot;)); //true 原文地址：博客园 https://www.cnblogs.com/meow999/p/12059917.html","categories":[{"name":"笔记","slug":"笔记","permalink":"http://liyang1998.gitee.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://liyang1998.gitee.io/tags/JavaScript/"}]},{"title":"JavaScript实现图片滚动","slug":"JavaScript-pic_move","date":"2019-12-10T13:13:14.000Z","updated":"2021-04-02T01:54:56.138Z","comments":true,"path":"20191210/JavaScript-pic_move/","link":"","permalink":"http://liyang1998.gitee.io/20191210/JavaScript-pic_move/","excerpt":"定时器应用：图片滚动分享一下最近学习的JavaScript定时器实现图片的无缝滚动。 间隔型定时器setInterval()与clearInterval() 12var timer = setInterval(func, delay); //第一个参数为定时器要执行的函数，第二个参数为定时器间隔，单位msclearInterval(timer); //停止定时器，参数为setInterval()所启动的定时器 原理和方法 让ul一直向左移动 – &gt; 减少left值 –&gt; offsetLeft() 1oUl.style.left&#x3D;oUl.offsetLeft-1+&#39;px&#39;; 复制li 我们演示的是div宽度可以容纳4张图片，而一共有4张图，所以我们要把4张图复制一份并接到后面 innerHTML 1oUl.innerHTML+=oUl.innerHTML; 修改ul的width 原先的ul宽度足以容纳内容，所以需要重新调整否则图片将分两行显示 1oUl.style.width=aLi[0].offsetWidth*aLi.length+&#x27;px&#x27;; 过界重设位置 当ul走完半程即第一份的4张图全部走出容器时，重设ul位置，回到起点，即可实现无缝滚动 判断: 1234if(oUl.offsetLeft&lt;-oUl.offsetWidth/2)&#123; oUl.style.left=&#x27;0&#x27;;&#125;","text":"定时器应用：图片滚动分享一下最近学习的JavaScript定时器实现图片的无缝滚动。 间隔型定时器setInterval()与clearInterval() 12var timer = setInterval(func, delay); //第一个参数为定时器要执行的函数，第二个参数为定时器间隔，单位msclearInterval(timer); //停止定时器，参数为setInterval()所启动的定时器 原理和方法 让ul一直向左移动 – &gt; 减少left值 –&gt; offsetLeft() 1oUl.style.left&#x3D;oUl.offsetLeft-1+&#39;px&#39;; 复制li 我们演示的是div宽度可以容纳4张图片，而一共有4张图，所以我们要把4张图复制一份并接到后面 innerHTML 1oUl.innerHTML+=oUl.innerHTML; 修改ul的width 原先的ul宽度足以容纳内容，所以需要重新调整否则图片将分两行显示 1oUl.style.width=aLi[0].offsetWidth*aLi.length+&#x27;px&#x27;; 过界重设位置 当ul走完半程即第一份的4张图全部走出容器时，重设ul位置，回到起点，即可实现无缝滚动 判断: 1234if(oUl.offsetLeft&lt;-oUl.offsetWidth/2)&#123; oUl.style.left=&#x27;0&#x27;;&#125; 图片演示 此图为初始结构示意 外层为div容器，内部为ul图片列表，4张图片，则设置div宽度等于图片宽度*4 如图，当ul向左移动后右侧没有内容进行显示，故我们进行复制li操作 （外层容器div设置overflow:hidden;属性，已经走出div范围的部分不会显示） 复制li后再进行移动则会产生如图所示效果（两侧超出内容隐藏） 当ul走完一半宽度（如图），此时显示内容原始内容相同，故我们重设ul位置，在视觉上实现无缝滚动 重设ul位置，回到初始状态 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;图片滚动&lt;/title&gt; &lt;style&gt; #div1&#123; position: relative; width: 1200px; height: 437px; margin: 100px auto; overflow: hidden; border-radius: 15px; &#125; .pic-list&#123; position: absolute; left: 0; top: 0; &#125; .pic-list li&#123; float: left; width: 300px; height: 437px; list-style: none; &#125; .pic-list img&#123; width: 300px; height: 437px; &#125; &lt;/style&gt; &lt;script&gt; window.onload=function ()&#123; var oDiv=document.getElementById(&#x27;div1&#x27;); var oUl=oDiv.getElementsByClassName(&#x27;pic-list&#x27;); var aLi=oUl.getElementsByTagName(&#x27;li&#x27;); oUl.innerHTML+=oUl.innerHTML; //将图片列表复制一份接到后面，长度必须大于等于div一次可显示长度 oUl.style.width=aLi[0].offsetWidth*aLi.length+&#x27;px&#x27;; //重新设置ul宽度=一个li宽度*li个数 //图片滚动函数 function move()&#123; //if条件判断作用： //当ul走完一半的时候重新回到原点，即可实现无缝滚动 if(oUl.offsetLeft&lt;-oUl.offsetWidth/2)&#123; oUl.style.left=&#x27;0&#x27;; &#125; oUl.style.left=oUl.offsetLeft-1+&#x27;px&#x27;; //每单位时间往左移动1px &#125; var timer = setInterval(move,30); //设置定时器，间隔30ms oDiv.onmouseover=function()&#123; //鼠标移入停止滚动 clearInterval(timer); &#125;; oDiv.onmouseout=function()&#123; //鼠标移出开始滚动 timer=setInterval(move,30); &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;ul class=&quot;pic-list&quot;&gt; &lt;li&gt;&lt;img src=&quot;img/1.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;img/2.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;img/3.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;img/4.jpg&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 小结这是之前学习的利用原生JS定时器制作图片滚动效果，比较基础，做一下记录总结 初学前端，小白一枚，有问题还望指正 欢迎志同道合的小伙伴与我交流o(￣▽￣)ブ","categories":[{"name":"笔记","slug":"笔记","permalink":"http://liyang1998.gitee.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://liyang1998.gitee.io/tags/JavaScript/"}]},{"title":"Hexo+Github个人博客搭建详细教程","slug":"Hexo-Github_blog","date":"2019-12-05T08:54:34.000Z","updated":"2021-04-02T01:54:56.138Z","comments":true,"path":"20191205/Hexo-Github_blog/","link":"","permalink":"http://liyang1998.gitee.io/20191205/Hexo-Github_blog/","excerpt":"概述使用Hexo搭建个人博客并利用GitHub进行部署。 很久之前就想搭建一个博客，可是也一直没有行动，最近在逛B站的时候发现一个up主（CodeSheep）的一个视频 《手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo》: https://www.bilibili.com/video/av44544186/ ，哈哈哈哈哈给他免费打个广告（虽然根本没人能看到），简直就是保姆级的教学视频，良心up主啊，真·手把手教学，大体浏览了一下以后我就坐不住了，马上起来开电脑行动！ 那在这里就简单总结一下过程和遇到的坑吧","text":"概述使用Hexo搭建个人博客并利用GitHub进行部署。 很久之前就想搭建一个博客，可是也一直没有行动，最近在逛B站的时候发现一个up主（CodeSheep）的一个视频 《手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo》: https://www.bilibili.com/video/av44544186/ ，哈哈哈哈哈给他免费打个广告（虽然根本没人能看到），简直就是保姆级的教学视频，良心up主啊，真·手把手教学，大体浏览了一下以后我就坐不住了，马上起来开电脑行动！ 那在这里就简单总结一下过程和遇到的坑吧 搭建博客博客是基于Hexo搭建的，需要Node.js、Git等支持 我用的是windows系统，而up主是在MacOS系统下操作的，其实大同小异。 安装Node.js 搜索引擎搜索Node.js或者直接访问 https://nodejs.org 下载左边那个LTS版本 下载完成后安装，使用 Node.js 官方安装程序时，请确保勾选 Add to PATH 选项（默认已勾选） 在cmd下分别输入命令行node -v和npm -v检查是否安装成功 安装Git 搜索引擎搜索git或者直接访问 https://git-scm.com/downloads 选择对应的操作系统下载 安装（在桌面或任意文件夹下右键菜单如果出现‘Git Bash Here’则说明成功） 安装cnpm（可选）由于国内镜像源速度较慢，所以先利用npm下载cnpm 在cmd中执行以下命令： npm install -g cnpm --registry=https://registry.npm.taobao.org 安装Hexo用以下命令安装hexo（没有安装cnpm则换成npm即可）： cnpm install -g hexo-cli 完成后运行hexo -v 查看版本以检查是否安装成功 开始搭建博客创建一个文件夹，例如：D:\\blog 转到此路径，然后运行hexo init进行初始化，也可以直接用hexo init D:\\blog 看到INFO Start blogging with Hexo!则说明成功 此时你会发现对应目录下已经为你自动生成了一些文件 12345678910111213C:\\WINDOWS\\system32&gt;d:D:\\&gt;cd blogD:\\blog&gt;D:\\blog&gt;hexo init或者直接C:\\WINDOWS\\system32&gt;hexo init D:\\blog...INFO Start blogging with Hexo!D:\\blog&gt; 启动只需要hexo server或者直接简写hexo s即可启动 123D:\\blog&gt;hexo sINFO Start processingINFO Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop. 看到以上提示说明启动成功，然后打开浏览器访问 http://localhost:4000 即可看到博客页面 新建文章用hexo new &quot;My New Post&quot;新建博客文章 12D:\\blog&gt;hexo new &quot;我的第一篇博客文章&quot;INFO Created: D:\\blog\\source\\_posts\\我的第一篇博客文章.md 可以看到生成的文件是.md后缀即markdown格式，你需要了解一下markdown 生成静态文件hexo generate或者hexo g 生成静态文件。 然后重新启动服务器即可看到新添加的文章了。 部署博客这里我们用利用Github将博客进行免费部署。 创建Github库首先你需要有一个Github账号，然后新建一个库，库的名字为：username.github.io 注意此处username必须为你的用户名！ 安装部署插件打开命令提示符，转到你的博客目录下安装部署插件，或者直接在文件夹下 右键-&gt;’Git Bash Here’，命令如下： cnpm install --save hexo-deployer-git 更改配置文件在你的目录找到名为_config.yml的文件，用文本编辑器打开文件，找到最下面的‘deploy’项，将内容改为如下： deploy: type: git repo: https://github.com/username/username.githu.io.git branch: master 注：username为你的用户名，repo其实就是你刚刚创建的库的地址加上后缀.git ！！！注意格式与缩进，冒号后有一个空格！！！ 当然你也可以在site项里更改博客网页的title、description、author等。 更改完成后保存。 进行部署命令很简单只需要一行hexo d即可，过程会提示你输入你的Github的账号密码，正确输入即可。 成功提示 INFO Deployer done: git 然后刷新你的仓库你会发现多了很多东西 访问博客地址部署完成后访问username.github.io 如果出问题的话将Git与Github的用户名改为一致后重试 1234567891011查看用户名和邮箱地址：git config user.namegit config user.email修改用户名和邮箱地址:git config --global user.name &quot;xxxx&quot;git config --global user.email &quot;xxxx&quot; 更换主题这里推荐的是github用户litten提供的yilia主题： https://github.com/litten/hexo-theme-yilia 方法： 下载 cmd或者git bash，在之前的D:\\blog目录下： git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 即将主题文件克隆到D:\\blog\\themes\\yilia目录下 配置 还是更改配置文件_config.yml，注意不是themes\\yilia目录下的，而是主目录下的 找到theme，将默认的landscape改为yilia，保存。注意冒号后的空格！！！ 完成后 12345678910hexo cleanhexo ghexo s访问 http:&#x2F;&#x2F;localhost:4000 查看或者hexo d -g重新部署博客 待更新…","categories":[{"name":"教程","slug":"教程","permalink":"http://liyang1998.gitee.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"http://liyang1998.gitee.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"http://liyang1998.gitee.io/tags/Hexo/"}]}],"categories":[{"name":"教程","slug":"教程","permalink":"http://liyang1998.gitee.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"笔记","slug":"笔记","permalink":"http://liyang1998.gitee.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"http://liyang1998.gitee.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://liyang1998.gitee.io/tags/JavaScript/"},{"name":"Hexo","slug":"Hexo","permalink":"http://liyang1998.gitee.io/tags/Hexo/"}]}